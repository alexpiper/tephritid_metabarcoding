---
title: "Qfly metabarcoding"
subtitle: "Primer design"
author: "Alexander Piper"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Introduction


# Optional: Run R on BASC
You may wish to run this workflow through the BASC command line in order to take advantage of more processing power. To do this, you can start a new SLURM interactive session. Press the CODE button to the lower right to display the code for this optional step.

```{bash, class.source = 'fold-hide'}
cd /group/pathogens/Alexp/Metabarcoding/tephritid_metabarcoding
# Create new interactive SLURM session
sinteractive --ntasks=1 --cpus-per-task=10 --mem-per-cpu=10GB --time=72:00:00

module load R/4.1.0-foss-2021a
module load pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2
module load GDAL/3.3.0-foss-2021a
module load BLAST+/2.11.0-gompi-2020a
module load Pandoc/2.5

# Load R
R

# Run quit() to quit R once you are finished
```


# Load packages
```{r setup}
#Set required packages
.cran_packages <- c("usethis",
                    "tidyverse",
                    "tidymodels",
                    "spider", 
                    "insect",
                    "ape",
                    "RColorBrewer",
                    "seqinr",
                    "patchwork",
                    "ShortRead",
                    "furrr",
                    "future",
                    "TmCalculator",
                    "castor",
                    "phangorn",
                    "tidytext")

.bioc_packages <- c("DECIPHER",
                    "Biostrings")

.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
   install.packages(.cran_packages[!.inst])
}
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install(.bioc_packages[!.inst], ask = F)
}

#Load all packages
sapply(c(.cran_packages,.bioc_packages), require, character.only = TRUE)

# Github packages
devtools::install_github("alexpiper/taxreturn")
devtools::install_github("ricardo-bion/ggradar",dependencies = TRUE)
devtools::install_github("YuLab-SMU/ggtree", dependencies = TRUE)
library(ggtree)
library(taxreturn)
library(PrimerMiner)
library(ggradar)

# SOurce internal functions
source("R/themes.R")
source("R/helper_functions.R")
```

# Download public reference sequences

```{R}
## Fetch tephritid sequences from GenBank
dir.create("diagnostic_alignments/public")
# COI
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="COI[GENE] OR COX1[GENE] OR COXI[GENE] OR cytochrome c oxidase subunit 1", output = "gb-binom", compress=TRUE, force=TRUE, multithread =FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_COI_COX1_COXI_cytochrome_c_oxidase_subunit_1.fa.gz", "diagnostic_alignments/public/Tephritidae_COI_genbank.fa.gz")

# EIF3L (eukaryotic translation initiation factor 3 subunit L)
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="eukaryotic translation initiation factor 3 subunit L", output = "gb-binom", compress=TRUE, force=TRUE, multithread =FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_eukaryotic_translation_initiation_factor_3_subunit_L.fa.gz", "diagnostic_alignments/public/Tephritidae_EIF3L_genbank.fa.gz")

# DDOST2 (dolichyl-diphosphooligosaccharide-protein glycosyltransferase subunit 2)
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="dolichyl-diphosphooligosaccharide-protein glycosyltransferase subunit 2", output = "gb-binom", compress=TRUE, force=TRUE, multithread =FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_dolichyl-diphosphooligosaccharide-protein_glycosyltransferase_subunit_2.fa.gz", "diagnostic_alignments/public/Tephritidae_DDOST2_genbank.fa.gz")

# POP4 (ribonuclease P protein subunit p29)
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="ribonuclease P protein subunit p29", output = "gb-binom", compress=TRUE, force=TRUE, multithread =FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_ribonuclease_P_protein_subunit_p29.fa.gz", "diagnostic_alignments/public/Tephritidae_POP4_genbank.fa.gz")

# RPA2 (replication protein A 32 kDa subunit)
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="replication protein A 32 kDa subunit", output = "gb-binom", compress=TRUE, force=TRUE, multithread =FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_replication_protein_A_32_kDa_subunit.fa.gz", "diagnostic_alignments/public/Tephritidae_RPA2_genbank.fa.gz")

# Fetch tephritid sequences from BOLD

## Fetch sequences from BOLD by searching for a taxon name
fetchSeqs("Tephritidae", database="bold", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="COI-5P", output = "gb-binom", compress=TRUE, force=TRUE, multithread = FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_COI-5P.fa.gz", "diagnostic_alignments/public/Tephritidae_COI_bold.fa.gz")


# Fetch tephritid mitogenomes from genbank
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", quiet=FALSE, marker="mitochondria", output = "gb-binom", compress=TRUE, multithread=FALSE, force=TRUE)


# Fetch tephritid sequences from recent papers
# Not published yet: https://www.biorxiv.org/content/10.1101/2020.11.23.394510v1
```

# Reformat inhouse sequence names

Also remove terminal gaps
```{r reformat inhouse}
# Get NCBI reference database
db <- taxreturn::get_ncbi_taxonomy()

dir.create("diagnostic_alignments/inhouse")
fs::dir_ls(path="diagnostic_alignments", glob = "*Bactrocera_*.fa*|*Melissa*.fa*") %>%
  purrr::map(function(x){
    seqs <- readDNAStringSet(x)
    new_names <- names(seqs) %>%
      trimws() %>%
      str_replace("sp._near_", "nr.")%>%
      str_replace("near_", "nr.")%>%
      str_remove("complex_")%>%
      str_remove("with_medial_spot_")%>%
      str_remove("_$")%>%
      str_split_fixed(pattern="_", n=3) %>%
      as.data.frame() %>%
      mutate(acc = na_if(V3, ""))%>%
      tidyr::unite(V1, V2, col="tax_name", sep = " ") %>%
      left_join(db) %>%
      dplyr::select(acc, tax_id, tax_name) %>%
      tidyr::unite(acc, tax_id,col="acc", sep="|") %>%
      tidyr::unite(acc, tax_name, col="names", sep=";") %>%
      pull(names)

    names(seqs) <- new_names
    
    # These seqs also have terminal N's instead of gaps. Replace these
    seqs <- replace_terminal_N(seqs)
    writeXStringSet(seqs, filepath = paste0("diagnostic_alignments/inhouse/", basename(as.character(x))))
  })

```


# Create PHMMs

Use only the validated diagnostic alignments to make the PHMMS

```{r create PHMMS}
dir.create("diagnostic_alignments/model")
fs::dir_ls(path="diagnostic_alignments", glob = "*Bactrocera_*.fa") %>%
  purrr::map(function(x){
    loci_name <- basename(as.character(x)) %>% 
      str_remove("^.*_") %>%
      str_remove(".fa")
    
    # Align all sequences
    aligned <- readDNAStringSet(x) %>%
      replace_terminal_N() %>%
      RemoveGaps()%>%
      AlignSeqs()
    
    # Remove sequences with >50% gaps
    aligned <- aligned[letterFrequency(aligned, "ACGT") > (width(aligned[1]) / 2)]
    
    # Filter for stop codons - NEED TO MAKE THIS DEAL WITH Ambiguities
    aligned <- taxreturn::codon_filter(aligned, genetic_code = ifelse(loci_name == "COI", "SGC4", "SGC0"), tryrc = TRUE, resolve_draws = "majority")
    
    #BrowseSeqs(aligned)
    
    # Create PHMM
    model <- aphid::derivePHMM(as.DNAbin(aligned), omit.endgaps = TRUE, seqweights="Gerstein")
  
    saveRDS(model, paste0(dirname(as.character(x)), "/model/", basename(as.character(x)) %>% str_replace(".fa", ".rds") %>% str_replace(".fa.gz", ".rds")))
})
```


# Merge all sequences

```{r merge alignments}
dir.create("diagnostic_alignments/merged")

# Merge sequences function
merge_seqs <- function(path, glob, out){
  if(file.exists(out)){file.remove(out)}
  file.create(out)
  files <- fs::dir_ls(path=path, glob = glob) 
  message("merging ", length(files), " fasta files")
  
  if(str_detect(out, ".gz"))(compress = TRUE)
  files %>%
  purrr::map(readDNAStringSet) %>%
  purrr::map(writeXStringSet, filepath=out, append=TRUE, width=20000, compress=compress)
}

#COI
merge_seqs(path=c("diagnostic_alignments/inhouse","diagnostic_alignments/public"), glob="*COI*.fa*|*mitochondria*.fa*", out = "diagnostic_alignments/merged/COI_merged.fa.gz")
  
# EIF3L
merge_seqs(path=c("diagnostic_alignments/inhouse","diagnostic_alignments/public"), glob="*EIF3L*.fa*", out = "diagnostic_alignments/merged/EIF3L_merged.fa.gz")

# DDOST
merge_seqs(path=c("diagnostic_alignments/inhouse","diagnostic_alignments/public"), glob="*DDOST*.fa*", out = "diagnostic_alignments/merged/DDOST_merged.fa.gz")

# POP4
merge_seqs(path=c("diagnostic_alignments/inhouse","diagnostic_alignments/public"), glob="*POP4*.fa*", out = "diagnostic_alignments/merged/POP4_merged.fa.gz")

# RPA2
merge_seqs(path=c("diagnostic_alignments/inhouse","diagnostic_alignments/public"), glob="*RPA2*.fa*", out = "diagnostic_alignments/merged/RPA2_merged.fa.gz")

# fix names, replace N's with gapsr
alignments_cleaned <- fs::dir_ls(path="diagnostic_alignments/merged/", glob = "*.fa*") %>%
  purrr::map(readDNAStringSet) %>%
  purrr::map(replaceAmbiguities, "-") %>%
  purrr::map(~{
    new_names <- names(.x) %>%
      str_replace_all("Bactrocera_unitaeneola", "Bactrocera_unitaeniola") %>%
      str_replace_all("Bactrocera_calendoniensis", "Bactrocera_caledoniensis") %>%
      str_replace_all("Zeugodacus_platumus", "Zeugodacus_platamus")%>%
      str_replace_all("Bactrocera_erubsecentis", "Bactrocera_erubescentis") %>%
      trimws()
    names(.x) <- new_names
    return(.x)
  }) 
  
alignments_cleaned %>%
  purrr::map2(names(alignments_cleaned), function(x,y){
    writeXStringSet(x, filepath=y, append=FALSE, width=20000,compress = TRUE)
  })

# Count number of sequences


```

# Filter sequences

```{r filter seqs}
# flag clusters with mixed taxonomy at different cluster thresholds and taxonomic ranks
db <- taxreturn::get_ncbi_taxonomy()
ncores <- 9
set.seed(666)

#x <- fs::dir_ls(path="diagnostic_alignments/merged", glob = "*.fa.gz*")[[1]]
to_remove <- readLines("diagnostic_alignments/mislabelled.txt")

dir.create("diagnostic_alignments/cleaned")

plan(multicore)
filt <- fs::dir_ls(path="diagnostic_alignments/merged", glob = "*.fa.gz")%>%
  purrr::map(function(x){
    loci_name <- basename(as.character(x)) %>% 
      str_remove("_.*$")
    
    seqs <- insect::readFASTA(x)
    names(seqs) <- names(seqs) %>% str_replace_all(" ", "_")
    #seqs <- seqs[1:100]

    # Remove any duplicated sequence accessions
    uniqSeqs <- seqs[!duplicated(str_remove(names(seqs), "\\|.*$"))]
    
    # Resolve taxonomic synonyms
    resolved <- resolve_synonyms_ncbi(uniqSeqs)
    
    #Check names difference
    #names(uniqSeqs)[which(!names(uniqSeqs) %in% names(resolved))]
    #names(resolved)[which(!names(resolved) %in% names(uniqSeqs))]
    
    # Filter sequeunces with bad names
    names_to_remove <- str_detect(names(resolved) %>% str_remove("^.*;") %>% str_replace("_", " "), "sp\\.|spp\\.|aff\\.|nr\\.|bv\\.|cf\\.|nom\\.|nud\\.|environment|undescribed|unverified|unclassified|uncultured|unidentif|[0-9]|[:punct:]")
    namefilt <- resolved[!names_to_remove]
    
    # Filter out putatively mislabelled seqs
    misannot <- namefilt[!names(namefilt) %in% to_remove]
    
    #load phmm
    model <- readRDS(fs::dir_ls(path="diagnostic_alignments/model", glob = paste0("*",loci_name,"*")))
    
    # Align to phmm
    #ifelse(loci_name == "COI", TRUE, FALSE)
    filtered <- taxreturn::map_to_model(misannot,  model, min_score = 100,
     shave=TRUE, trim_ends = 4, check_frame=TRUE,  max_N = 5, max_gap=(model$size/3), extra="drop", kmer_threshold = 0.3, k = 5,
     multithread=ncores, quiet=FALSE, progress = FALSE)
    
    # Check for stop codons
    codonfilt <- taxreturn::codon_filter(filtered, genetic_code = ifelse(loci_name == "COI", "SGC4", "SGC0"), tryrc = TRUE, resolve_draws = "majority")
    
    # Check for mixed clusters (misannotated sequences)
    mixed_clusters <- taxreturn::get_mixed_clusters(codonfilt, db, rank="species", threshold=0.99, return="consensus", confidence=0.8, quiet=FALSE)
    purged  <- subset.DNAbin(codonfilt, subset = !str_replace(names(codonfilt), "(?:.(?!;))+$", "") %in% mixed_clusters$Acc)
 
    # prune overrepresented groups - prefering inhouse sequences in case of ties
    prefered_taxa <- fs::dir_ls("diagnostic_alignments/inhouse", glob=paste0("*",loci_name,"*")) %>%
      map(function(x){
        names(insect::readFASTA(x))
      })%>%
      unlist() %>%
      unname()

    pruned <- prune_groups(purged, max_group_size = 5, discardby = "length", dedup = TRUE, prefer=prefered_taxa, quiet = FALSE)
    
	  #Write out results filtered results
    insect::writeFASTA(pruned, file=paste0("diagnostic_alignments/cleaned/", loci_name, ".fa.gz"), compress=TRUE)

    
    #Trace each sequence through filtering
    seq_tracker <- tibble::enframe(names(seqs), name=NULL, value="seq") %>%
      tidyr::separate(seq, into=c("acc", "tax_id", "species"), sep = "\\||;") %>%
      mutate(uniqseqs = case_when(
        acc %in% (names(uniqSeqs) %>% str_remove("\\|.*$")) ~ TRUE,
        !acc %in% (names(uniqSeqs) %>% str_remove("\\|.*$")) ~ FALSE
      ),
      namefilt = case_when(
        acc %in% (names(namefilt) %>% str_remove("\\|.*$")) ~ TRUE,
        !acc %in% (names(namefilt) %>% str_remove("\\|.*$")) ~ FALSE
      ),
      misannot = case_when(
        acc %in% (names(misannot) %>% str_remove("\\|.*$")) ~ TRUE,
        !acc %in% (names(misannot) %>% str_remove("\\|.*$")) ~ FALSE
      ),
      phmm = case_when(
        acc %in% (names(filtered) %>% str_remove("\\|.*$")) ~ TRUE,
        !acc %in% (names(filtered) %>% str_remove("\\|.*$")) ~ FALSE
      ),
      codonfilt = case_when(
        acc %in% (names(codonfilt) %>% str_remove("\\|.*$")) ~ TRUE,
        !acc %in% (names(codonfilt) %>% str_remove("\\|.*$")) ~ FALSE
      ),
      purged = case_when(
        acc %in% (names(purged) %>% str_remove("\\|.*$")) ~ TRUE,
        !acc %in% (names(purged) %>% str_remove("\\|.*$")) ~ FALSE
      ),
      pruned = case_when(
        acc %in% (names(pruned) %>% str_remove("\\|.*$")) ~ TRUE,
        !acc %in% (names(pruned) %>% str_remove("\\|.*$")) ~ FALSE
      ), loci = loci_name)

    return(seq_tracker)
})%>%
  bind_rows()


write_csv(filt, "filter_stats.csv")


target_list <- readxl::read_xlsx("sample_data/180613 _ALL FF_Lucid Key_NAQS flies.xlsx") %>%
  janitor::clean_names() %>%
  dplyr::select(lure = trap_lure_type, genus, species) %>%
  mutate(species = paste0(genus, " ", species))

filt <- read_csv("filter_stats.csv")


test <- target_list %>% 
  mutate(species = species %>% str_replace_all(" ", "_"))%>%
  left_join(filt)

# Summarise number of seqs remaining for each loci
filt %>%
  group_by(loci) %>%
  summarise(starting = n(),
            final = sum(pruned == TRUE),
            perc = scales::percent(final / starting,accuracy = 0.1))

# Output summary of cleanup for supplementary 
filt %>%
  pivot_longer(-c("acc", "tax_id", "species", "loci"),
               names_to="stage",
               values_to = "kept") %>%
  group_by(loci, stage) %>%
  summarise(kept = sum(kept==TRUE)) %>%
  ungroup()%>%
  mutate(stage = factor(stage, levels=c("uniqseqs","namefilt","misannot","phmm","codonfilt","purged","pruned"))) %>%
  ggplot(aes(x = stage, y = kept, fill=loci))+
  geom_col() +
  geom_text(aes(label=kept), colour="white",nudge_y = -50)+
  facet_grid(loci~., scales="free_y")+
  scale_fill_brewer(palette="Set1")

filt %>%
  pivot_longer(-loci,
               names_to="step",
               values_to="seqs") %>%
  mutate(step = factor(step, levels=c("seqs", "uniqseqs", "namefilt", "phmm", "codonfilt", "purged"))) %>%
  ggplot(aes(x = step, y = seqs))+
  geom_col()+
  facet_grid(loci~., scales="free_y")

```

# Entropy

```{r entropy}
#Set moving average function - Adjust smoothing (n=5?)
ma <- function(x, n=3, sides=2){
  if(length(x) >= n){stats::filter(x, rep(1/n, n), sides=sides)
    }else NA_real_
  }


# Entropy & Basecomp bar plots
entropy_plots <- fs::dir_ls(path="diagnostic_alignments/cleaned", glob = "*.fa.gz") %>%
  purrr::map(function(x){
    seqs <- insect::readFASTA(x)
    ent <- taxreturn::alignment_entropy(as.list(seqs), mask_gaps=1, count_gaps=FALSE, 
                                        method="ML", unit="log", return_extra = TRUE) %>%
      ungroup() %>%
      mutate(ent = ent %>% 
               na_if("") %>%
               replace_na(0)) %>%
      mutate(ma = ma(ent, n = 3, sides=1)) %>%
      mutate(ma = ma %>% replace_na(0))
    
    # Plot entropy
    gg.ent <- ent %>%
      mutate(pos = as.numeric(pos)) %>%
      ggplot(aes(x = pos, y = ma))+
      geom_line() +
      theme_void()+
          scale_x_continuous(expand=c(0,0), breaks = seq(0, max(lengths(seqs)), 10))+
          scale_y_continuous(expand=c(0,0)) +
      labs( title = x %>% 
             str_remove("_aligned.*$") %>%
             str_remove("^.*/"))
    
    # Plot basecomposition
    gg.basecomp <- ent %>%
      pivot_longer(c("A", "C", "G", "T"),
                   names_to = "base",
                   values_to="value") %>%
      group_by(pos) %>%
      mutate(prob = value / sum(value)) %>%
      mutate(pos = as.numeric(pos)) %>%
      ggplot(aes(x = pos, y = prob, fill=base))+
      geom_col() +
      theme_bw()+
      scale_x_continuous(expand=c(0,0), breaks = seq(0, max(lengths(seqs)), 10))+
      scale_y_continuous(expand=c(0,0), labels=scales::percent_format()) +
      labs(x = NULL,
           y = NULL,
           fill="Base")+
      scale_fill_manual(values=c("A" = "firebrick", "T" = "green", "G" = "goldenrod", "C" = "mediumblue"))
  
    gg.ent / gg.basecomp
    
    })

gg.entropy <- wrap_plots(entropy_plots, ncol=1)

gg.entropy

pdf(file="fig/entropy_basecomp.pdf", width = 50, height = 8)
  plot(gg.entropy)
try(dev.off(), silent=TRUE)
```


# Sliding window analysis

sinteractive --cpus-per-task=5 --mem-per-cpu=20GB --time=48:00:00
module load R/4.0.0-foss-2020a
module load GDAL/3.0.2-foss-2019a-Python-3.7.2


```{r sliding window}
# Set window parameters
win_length <- c(220, 420)
win_int <- 3

future::plan(future::multicore(workers=8))

sw_results <- fs::dir_ls(path="diagnostic_alignments/cleaned", glob = "*.fa.gz") %>%
  furrr::future_map(function(x){
  print(x)
  seqs <- readDNAStringSet(x)
  #seqs <- seqs[1:100]
  
  # species names
  spp_names <- names(seqs) %>%
    str_remove("^.*;")
  #names(seqs) <- spp_names
  
  # Make a DNA matrix
  dat <- as.matrix(seqs)
  #dimnames(dat)[[1]] <- spp_names

  # Make full distance matrix
  datd <- DECIPHER::DistanceMatrix(seqs, includeTerminalGaps = FALSE, penalizeGapLetterMatches = TRUE,
                                   penalizeGapGapMatches = FALSE, correction = "Jukes-Cantor", processors = 1, verbose = TRUE)

  # Create NJ tree from entire distance matrix
  dat_tr <- bionjs(datd) # try njs, bionjs, nj, and bionj and see how it changes things
  
  # Fix any negative edge lengths
  dat_tr <- fix_negative_edge_length(dat_tr, collapse_multi = TRUE)
  
  # Identification success with full tree 
  full_mono <- tibble(spp = unique(spp_names), 
               mono = monophyly(dat_tr, spp_names))
  full_nn <- tibble(seqs = names(seqs),
               spp = spp_names, 
               nn = nearNeighbour(datd, spp_names))

  # Sliding windows
  window_results <- vector("list", length=length(win_length))
  for (w in 1:length(win_length)){
    
    # Create windows
    win <- alignment_sw(seqs, width= win_length[w], interval=win_int, maxgaps = 10)
    win_spp_names <- purrr::map(win, ~{
      names(.x) %>%
      str_remove("^.*;")
    })

    #win <- slidingWindow(seqs, width=win_length[w], interval = win_int)
    pos_out <- sapply(win, function(x) attr(x, "window")[1])
    
    # Create distance matrices for each window
    win_dist <- lapply(win, function(x){
      DECIPHER::DistanceMatrix(x, includeTerminalGaps = FALSE, penalizeGapLetterMatches = TRUE,
                                   penalizeGapGapMatches = FALSE, correction = "Jukes-Cantor", processors = 1, verbose = FALSE)
      
    }) 

    # Get mean K2P distance per window
    dist_mean_out <- sapply(win_dist, function(x) mean(x, na.rm = TRUE))
    
    # Get number of diagnostic nucleotides
    #slideNucDiag(dat, spp_names, width=win_length[w], interval = win_int)
    #nd_out <- colSums(nd_out)
    
    #depth <- which(node.depth(dat_tr)[node.depth(dat_tr) > 1] <= median(node.depth(dat_tr)[node.depth(dat_tr) > 1]))

    ## Make NJ trees for each window
    win_tr <- purrr::map2(win_dist, pos_out,~{
      print(.y)
      # Filter out comparisons that are only NA
      y <- as.matrix(.x)
      y <- y[rowSums(.x, na.rm = TRUE) > 0, colSums(.x, na.rm = TRUE) > 0]
      tree <- bionjs(.x)
      tree <- fix_negative_edge_length(tree, collapse_multi = TRUE)
    })
      
    #Proportion of species that are monophyletic.
    win_mono <- purrr::map2(win_tr, win_spp_names, ~{
        tibble(spp = unique(.y), 
               mono = monophyly(.x, .y)) %>%
          left_join(full_mono %>% dplyr::rename(full_mono = mono), by="spp") %>%
          mutate(mono_both = mono == full_mono)
      })
    
    # Get the proportion of monophyletic spp only counting ones monophyletic on full tree 
    win_mono_comp <- win_mono %>%
      purrr::map_dbl(~{
        length(which(.x$mono_both))/length(.x$mono_both)
      })
    
    # Get total proportion of monophyletic spp
    win_mono_all <- win_mono %>%
      purrr::map_dbl(~{
        length(which(.x$mono))/length(.x$mono)
      })
    
    #NN
    win_nn <- purrr::map2(win_dist, win_spp_names, ~{
        #length(rownames(.y))
        tibble(seqs = rownames(.x),
               spp = .y, 
               nn = nearNeighbour(.x, .y)) %>%
          left_join(full_nn %>% dplyr::rename(full_nn = nn), by = c("seqs", "spp")) %>%
          mutate(nn_both = nn == full_nn)
      })
    
    # Get the proportion of successful ID's only counting ones successful with full-length 
    win_nn_comp <- win_nn %>%
      purrr::map_dbl(~{
        length(which(.x$nn_both))/length(.x$nn_both)
      }) 
    # Get total proportion of successful ID's
    win_nn_all <- win_nn %>%
      purrr::map_dbl(~{
        length(which(.x$nn))/length(.x$nn)
      })
    
    # threshID
    #win_threshid <- lapply(win_dist, function(x) threshID(x, spp_names, threshold = 0.01))
    
    window_results[[w]] <- data.frame(win_length = win_length[w],
      pos = pos_out,
      k2p_dist = dist_mean_out,
      mono_comp = win_mono_comp,
      mono_all = win_mono_all,
      nn_comp = win_nn_comp,
      nn_all = win_nn_all,
      n_seqs = length(seqs),
      n_spp = length(unique(spp_names))
    )%>%
      mutate(win_mono = win_mono,
        win_nn = win_nn)
  }
  
  # Create output
  out <- window_results  %>%
    bind_rows()
  return(out)
},.options = furrr_options(seed=TRUE) )



sw_merged <- sw_results %>%
  bind_rows(.id = "source") %>%
  mutate(source = source %>% 
             str_remove("_aligned.*$") %>%
             str_remove("^.*/"))

saveRDS(sw_merged, "output/rds/sw_merged.rds")


```


# SW results

```{r Analyse SW}
sw_merged <- readRDS("output/rds/sw_merged.rds") %>%
  dplyr::select(-where(is.list)) %>%
  mutate(source = source %>% str_remove(".fa.gz"))
# Could maybe put them all on the same grid?

se <- function(x) sd(x) / sqrt(length(x)) # Create own function

# Get the best positions from each and create an amplicon from there (see primer eval code for creating the amplicon)
best_windows <- sw_merged %>%
  drop_na() %>%
  dplyr::select(-where(is.list)) %>%
  group_by(source, win_length) %>%
  #arrange(mono_comp, nn_comp) %>%
  slice_max(order_by=mono_comp, with_ties = TRUE) %>%
  slice_max(order_by=nn_comp, with_ties = TRUE) %>%
  slice_max(order_by=k2p_dist, with_ties = TRUE) 

id_success_range <- sw_merged %>%
  drop_na() %>%
  dplyr::select(-where(is.list)) %>%
  group_by(source, win_length) %>%
  summarise(max_mono = max(mono_comp), 
            min_mono = min(mono_comp),
            mean_mono = mean(mono_comp),
            se= se(mono_comp))
  #arrange(mono_comp, nn_comp) %>%
  slice_max(order_by=mono_comp, with_ties = TRUE) %>%
  slice_max(order_by=nn_comp, with_ties = TRUE) %>%
  slice_max(order_by=k2p_dist, with_ties = TRUE) 


# All metrics
gg.sw_comparison <- sw_merged %>%
  dplyr::select(-where(is.list)) %>%
  filter(is.finite(k2p_dist), !win_length == "320") %>%
  pivot_longer(c("mono_comp", "nn_comp", "k2p_dist"),
               names_to="metric",
               values_to="value") %>%
  ungroup()%>%
  ggplot(aes(x = pos, y = value, colour=metric))+
  geom_line() + 
  geom_vline(data=best_windows, aes(xintercept=pos, colour=factor(win_length))) +
  base_theme+
  facet_grid(source~win_length)+
  scale_x_continuous(expand=c(0,0), breaks = seq(0, max(sw_merged$pos), 20))+
  scale_y_continuous(expand=c(0,0), limits=c(0,1), labels = scales::percent_format()) +
  scale_color_brewer(palette="Set1")+
  theme(panel.grid = element_blank(),
        legend.position = "right",
        axis.text.x = element_text(angle=0, hjust=0.5)) +
  labs(x = "Nucleotide position within alignment",
       y = "Proportion monophyletic (Compared to full tree)",
       colour = "Amplicon length")

gg.sw_comparison

pdf(file= "fig/sw_all.pdf", width = 11, height = 8, paper="a4r")
  plot(gg.sw_comparison)
try(dev.off(), silent=TRUE)


# Just tree monophyly comparison
gg.mono_comparison <- sw_merged %>%
  filter(is.finite(k2p_dist), !win_length == "320") %>%
  pivot_longer(c("mono_comp"),
               names_to="metric",
               values_to="value") %>%
  ungroup()%>%
  ggplot(aes(x = pos, y = value, colour=factor(win_length)))+
  geom_line() + 
  geom_vline(data=best_windows, aes(xintercept=pos, colour=factor(win_length))) +
  base_theme+
  facet_grid(source~.)+
  scale_x_continuous(expand=c(0,0), breaks = seq(0, max(sw_merged$pos), 20))+
  scale_y_continuous(expand=c(0,0), limits=c(0,1), labels = scales::percent_format()) +
  scale_color_brewer(palette="Set1")+
  theme(panel.grid = element_blank(),
        legend.position = "right",
        axis.text.x = element_text(angle=0, hjust=0.5)) +
  labs(x = "Nucleotide position within alignment",
       y = "Proportion monophyletic (Compared to full tree)",
       colour = "Amplicon length")

gg.mono_comparison

pdf(file= "fig/sw_monophyly.pdf", width = 11, height = 8, paper="a4r")
  plot(gg.mono_comparison)
try(dev.off(), silent=TRUE)
  
```

# Figure 1

```{r}

# Will need to pad out with largest alignment
alignment_pos <- fs::dir_ls(path="diagnostic_alignments/cleaned", glob = "*.fa.gz") %>%
  purrr::map_dbl(function(x){
    seqs <- insect::readFASTA(x)
    max(lengths(seqs))
  })
ref_pos <- tibble(pos =seq(1,max(alignment_pos),1))


# Entropy & Basecomp bar plots
seqlogo_plots <- fs::dir_ls(path="diagnostic_alignments/cleaned", glob = "*.fa.gz") %>%
  purrr::map(function(x){
    seqs <- insect::readFASTA(x)
    ent <- taxreturn::alignment_entropy(as.list(seqs), mask_gaps=1, count_gaps=FALSE, 
                                        method="ML", unit="log", return_extra = TRUE) %>%
      ungroup() %>%
      mutate(ent = ent %>% 
               na_if("") %>%
               replace_na(0)) %>%
      mutate(ma = ma(ent, n = 3, sides=1)) %>%
      mutate(ma = ma %>% replace_na(0)) %>%
      mutate(source = basename(x) %>% str_remove(".fa.gz")) %>%
      mutate(pos = as.numeric(pos)) %>%
      group_by(source) %>%
      mutate(max_ma = max(ma)) %>%
      mutate(scaled_ent = ma / max(ma))
    
    loci_name <- unique(ent$source)
    
    # Get binding position of primers
    model <- readRDS(fs::dir_ls(path="diagnostic_alignments/model", glob = paste0("*",loci_name,"*")))
    primers <- read_csv("primer_candidates.csv") %>%
      dplyr::filter(loci == loci_name, final) %>%
      seqateurs::coalesce_join(.$Fseq %>% purrr::map(get_binding_position, model, tryrc = FALSE, min_score=8) %>%
              bind_rows() %>%
              dplyr::rename(Fseq = primer, Fstart = start, Fend = end, Fscore = score ),
              by="Fseq") %>%
       seqateurs::coalesce_join(
         .$Rseq %>% purrr::map(get_binding_position, model, tryrc = TRUE, min_score=8) %>%
         bind_rows() %>%
         dplyr::rename(Rseq = primer, Rstart = start, Rend = end, Rscore = score ),
         by="Rseq")%>%
       distinct()
    
    # Plot entropy
  ent_plot_dat <- ref_pos %>%
    left_join(ent %>% dplyr::select(source, pos, ent, ma, scaled_ent)) %>%
    mutate(source = loci_name) 
  
  sw_for <- ref_pos%>%
    left_join(sw_merged %>%
    filter(is.finite(k2p_dist), win_length == "220", source == loci_name) )%>%
    mutate(source = loci_name) 
  sw_rev <- ref_pos%>%
    left_join(sw_merged %>%
    filter(is.finite(k2p_dist), win_length == "220", source == loci_name) %>%
      mutate(new_pos = pos + 220) 
      #mutate(new_pos = max(ref_pos$pos)-pos)
      )%>%
    mutate(source = loci_name)
    
  gg.ent_mono <- ggplot(ent_plot_dat)+
    geom_rect(data=primers, 
              aes(xmin=Fend, xmax=Rend, 
                  ymin=0, ymax=1), color="transparent", fill="grey40", alpha=0.3) +
    geom_rect(data=primers, 
              aes(xmin=Fstart, xmax=Fend, 
                  ymin=0, ymax=1), color="transparent", fill="blue", alpha=0.3) +
    geom_rect(data=primers, 
              aes(xmin=Rend, xmax=Rstart, 
                  ymin=0, ymax=1), color="transparent", fill="red", alpha=0.3)+
    geom_line(data=sw_for[!is.na(sw_for$mono_comp),], aes(x = pos, y = mono_comp), colour="blue", size=1) + 
    geom_line(data=sw_rev[!is.na(sw_rev$mono_comp),], aes(x = new_pos, y = mono_comp), colour="red", size=1) + 
    geom_line(aes(x = pos, y = scaled_ent), colour="black") + 
    geom_segment(data = primers,
               aes(x = Fstart, xend = Fend,
                   y = 0.75, yend = 0.75), colour="blue", size = 1, arrow = arrow(length = unit(0.3,"cm")),
               show.legend = FALSE) +
    geom_text(data = primers,
            aes(x = Fstart, y = 0.75,
                label = Fname ),
            colour="blue", hjust = 1, show.legend = FALSE) +
    geom_segment(data = primers,
           aes(x = Rend, xend = Rstart,
               y = 0.75, yend = 0.75), colour="red", size = 1, arrow = arrow(length = unit(0.3,"cm")),
           show.legend = FALSE) +
    geom_text(data = primers,
            aes(x = Rend, y = 0.75,
                label = Rname ),
            colour="red", hjust = 0, show.legend = FALSE) +
    base_theme+
    facet_grid(~source)+
    scale_x_continuous(expand=c(0,0), breaks = seq(0, max(sw_merged$pos), 20))+
    scale_y_continuous(expand=c(0,0), limits=c(0,1), labels = scales::percent_format(),
                       # sec.axis = sec_axis(~ ., name = "Relative Sequence Entropy", labels = scales::percent_format())
                       ) +
    scale_color_brewer(palette="Set1")+
    theme(panel.grid = element_blank(),
          legend.position = "none",
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    labs( x = NULL,
         y = NULL,
         colour = "Amplicon length")

    
    # Plot basecomposition
    gg.basecomp <- ref_pos %>%
      left_join(ent) %>%
      mutate(A = replace_na(A, 0),
             C = replace_na(C, 0),
             G = replace_na(G, 0),
             `T` = replace_na(`T`, 0)) %>%
      pivot_longer(c("A", "C", "G", "T"),
                   names_to = "base",
                   values_to="value") %>%
      group_by(pos) %>%
      mutate(prob = case_when(
        sum(value) > 0 ~ value / sum(value),
        TRUE ~ 0)) %>%
      ggplot(aes(x = pos, y = prob, fill=base))+
      geom_col() +
      base_theme+
      scale_x_continuous(expand=c(0,0), breaks = seq(0, max(ref_pos$pos), 50))+
      scale_y_continuous(expand=c(0,0), labels=scales::percent_format()) +
      labs(x = NULL,
           y = NULL,
           fill="Base")+
      theme(axis.text.y = element_blank(),
            axis.ticks.y = element_blank(),
            panel.grid = element_blank(),
            axis.text.x = element_text(angle=0,hjust = 0.5),
            legend.position = "none",
          plot.margin = unit(c(0, 0, 0.25, 0), "cm")) +
      scale_fill_manual(values=c("A" = "firebrick", "T" = "green", "G" = "goldenrod", "C" = "mediumblue"))
  
    gg.ent_mono / gg.basecomp + plot_layout(heights = c(3,1)) 
    
    })

gg.fig1 <- wrap_plots(seqlogo_plots, ncol=1)

gg.fig1

# Blue line = Forward sliding window
# Red line = reverse sliding window
# Black line = Relative sequence entropy

pdf(file= "fig/Fig1_primer_design.pdf", width = 8, height = 11, paper="a4")
  plot(gg.fig1)
try(dev.off(), silent=TRUE)

```

# Virtual PCR's

```{r virtual pcrs}

dir.create("diagnostic_alignments/amplicons")

# VirutalPCR
fs::dir_ls(path="diagnostic_alignments/cleaned", glob = "*.fa.gz") %>%
  purrr::map(function(x){
    print(x)
    loci_name <- basename(as.character(x)) %>% 
    str_remove("\\..*$")
    
    seqs <- readDNAStringSet(x)
    
    # Get best windows
    win_dat <- best_windows %>%
      filter(source == loci_name)

    # Get binding position of primers
    model <- readRDS(fs::dir_ls(path="diagnostic_alignments/model", glob = paste0("*",loci_name,"*")))
    primers <- read_csv("primer_candidates.csv") %>%
      dplyr::filter(loci == loci_name, final) %>%
      seqateurs::coalesce_join(.$Fseq %>% purrr::map(get_binding_position, model, tryrc = FALSE, min_score=8) %>%
              bind_rows() %>%
              dplyr::rename(Fseq = primer, Fstart = start, Fend = end, Fscore = score ),
              by="Fseq") %>%
       seqateurs::coalesce_join(
         .$Rseq %>% purrr::map(get_binding_position, model, tryrc = TRUE, min_score=8) %>%
         bind_rows() %>%
         dplyr::rename(Rseq = primer, Rstart = start, Rend = end, Rscore = score ),
         by="Rseq")%>%
       distinct()
    print(primers)
    # Amplicons
    amplicons <- win_dat %>%
      mutate(start = pos+1, 
             end = pos + win_length,
             win_length = as.character(win_length)) %>%
      dplyr::select(source, win_length, start, end) %>%
      bind_rows(primers %>% 
                mutate(start = Fend,
                       end = Rstart,
                       win_length = paste0(Fname,"-", Rname))%>%
                dplyr::select(source = loci,win_length, start, end))
    
    for (p in 1:nrow(amplicons)){
      amplicon <- Biostrings::subseq(seqs, start=amplicons$start[p], end = amplicons$end[p]) #may need to add 1 to start
    
        #maxgaps <- 9 # dont allow any more than 9 gaps
        #rem <- names(amplicon)[Biostrings::letterFrequency(amplicon, "-") > maxgaps]
        #amplicon <- amplicon[!names(amplicon) %in% rem]
        out_name <- paste0(amplicons$source[p],"_", amplicons$win_length[p])
        #message(paste0(length(rem), " Sequences with more than ", maxgaps, 
        #               " gaps removed from ",out_name))
        Biostrings::writeXStringSet(amplicon, file=paste0("diagnostic_alignments/amplicons/", out_name,".fa.gz"), compress=TRUE)
      }
  })

```

# Loci combinatiosn

Find mix of loci that covers the most amount of species

- Combine all unique spp names covered across all alignments
- Run ID success on full locus

‘A taxon unambiguously identified by a primer pair owns a barcode sequence associated to
this pair that is not shared by any other taxa’.

```{r id results}
# Read in target list
#target_list <- readxl::read_xlsx("sample_data/Metabarcoding target list.xlsx") %>%
#  janitor::clean_names() %>%
#  mutate(genus = genus %>% str_remove(" .*$")) %>%
#  mutate(species = paste0(genus, " ", species))


target_list <- readxl::read_xlsx("sample_data/180613 _ALL FF_Lucid Key_NAQS flies.xlsx") %>%
  janitor::clean_names() %>%
  dplyr::select(lure = trap_lure_type, genus, species) %>%
  mutate(genus = genus %>% str_remove(" .*$")) %>%
  mutate(species = paste0(genus, " ", species))

# Cue lure 
cue_list <- target_list %>%
  filter(lure == "CUE") %>%
  pull(species)

# Cue lure 
me_list <- target_list %>%
  filter(lure == "ME") %>%
  pull(species)  

# copy the full length aligned sequences over
fs::dir_ls(path="diagnostic_alignments/cleaned/", glob = "*.fa.gz") %>%
  purrr::map(function(x){
    file.copy(x, paste0("diagnostic_alignments/amplicons/", str_replace(basename(as.character(x)), ".fa", "_full.fa")), overwrite = TRUE)
  })

# Filter these sequences 
to_remove <- readLines("diagnostic_alignments/mislabelled.txt")

# Get ID success with all
x <- fs::dir_ls(path="diagnostic_alignments/amplicons/", glob = "*.fa*") [[1]]

#id_success <- id_success[str_detect(id_success, "_full")]

id_success <- fs::dir_ls(path="diagnostic_alignments/amplicons/", glob = "*.fa*") %>%
  purrr::map(function(x){
  print(x)
  input_seqs <- readDNAStringSet(x)

  # Filter misannotated
  input_seqs <- input_seqs[!names(input_seqs) %in% to_remove]
  
  loci_name <- basename(as.character(x)) %>% str_remove(".fa.gz")

  dataset <- c("all","dacine", "target") #"me", "cue"
  res <- vector("list", length=length(dataset))
  for (d in 1:length(dataset)){
    print(dataset[d])
    seqs <- input_seqs
    
    # Subset to relevant taxa dataset
    if(dataset[d] == "dacine"){
      seqs <- seqs[str_detect(names(seqs) %>% 
                                str_remove("^.*;") %>%
                                str_remove(" .*$") %>%
                                str_replace("_", " "), "Bactrocera|Dacus|Zeugodacus|Monacrostichus")]
    }else if (dataset[d] == "target"){
      seqs <- seqs[(names(seqs) %>% str_remove("^.*;") %>%
                      str_replace("_", " ")) %in% target_list$species]
    }else if (dataset[d] == "cue"){
      seqs <- seqs[(names(seqs) %>% str_remove("^.*;") %>% 
                      str_replace("_", " ")) %in% cue_list]
    }else if (dataset[d] == "me"){
      seqs <- seqs[(names(seqs) %>% str_remove("^.*;") %>% 
                      str_replace("_", " ")) %in% me_list]
    }
    
    seq_names <- names(seqs)
    spp_names <- names(seqs) %>%
        str_remove("^.*;")
    names(seqs) <- spp_names
   
    # Make full distance matrix
    datd <- DECIPHER::DistanceMatrix(seqs, includeTerminalGaps = FALSE, penalizeGapLetterMatches = TRUE,
                                     penalizeGapGapMatches = FALSE, correction = "Jukes-Cantor", processors = 1, verbose = TRUE)
  
    # Create NJ tree from entire distance matrix
    dat_tr <- bionjs(datd) # try njs, bionjs, nj, and bionj and see how it changes things
    
    # Fix any negative edge lengths
    dat_tr <- fix_negative_edge_length(dat_tr, collapse_multi = TRUE)
    
    # Identification success with full tree 
    full_mono <- tibble(spp = unique(spp_names), 
                 mono = monophyly(dat_tr, spp_names))
    full_nn <- tibble(seqs = seq_names,
                 spp = spp_names, 
                 nn = nearNeighbour(datd, spp_names))
    
    #full_diag <- tibble(spp = unique(spp_names), 
    #             diag = as.numeric(nucDiag(datd, spp_names)))
    
    full_bcm <- tibble(seqs = seq_names,
                 bcm = bestCloseMatch(datd, spp_names, threshold=0.03))
    
    # Need to add a completely unique ID success criteria
    dat_tr$tip.label <- seq_names
    res[[d]] <- full_nn %>%
      left_join(full_bcm, by="seqs") %>%
      left_join(full_mono, by="spp") %>%
      mutate(loci = loci_name, dataset = dataset[d]) %>%
      dplyr::select(loci, dataset, spp, seqs, mono, nn, bcm) %>% 
      group_by(loci, dataset) %>% 
      nest() %>% 
      mutate(tree = list(dat_tr))
    
    # Create plot of full tree

    p1 <- ggtree(dat_tr)
    
    tree_labels <- p1$data %>% 
      mutate(spp = label %>% str_remove("^.*;")) %>%
      left_join(full_mono, by="spp")
    
    p2 <- p1 %<+% tree_labels + 
      geom_tippoint(aes(colour=mono)) +
      geom_tiplab()+
      theme(legend.position = "top")+
      labs(colour = "Monophyletic") +
      scale_colour_manual(values=c("#e41a1c","#4daf4a")) + 
      scale_x_continuous(expand=c(-0.8, 0.4))
    
    # Save figure
    out.dir <-"output/trees/"
    if(!dir.exists(out.dir)){ dir.create(out.dir)}
    
    #Might be worth changing output height depending on number of seqs
    plot_height <- round(length(spp_names) / 7)
    pdf(file= paste0(out.dir,loci_name,"_",dataset[d], ".pdf"), width = 20, height = plot_height)
      plot(p2)
    try(dev.off(), silent=TRUE)
      
    # Write out newick
    out.dir <-"output/trees/newick/"
    if(!dir.exists(out.dir)){ dir.create(out.dir)}
    write.tree(dat_tr, paste0(out.dir,loci_name,"_",dataset[d], ".nwk") )
  }
  out <- res %>%
    dplyr::bind_rows()
  
  return(out)
}) %>% 
  bind_rows()


# make supertree to arrange plot around only using hte full matrices
tree_list <- id_success %>%
  filter(str_detect(loci, "full"), dataset=="all") %>%
  pull(tree) 
class(tree_list) <- "multiPhylo"
supertree <- phangorn::superTree(tree_list)

saveRDS(supertree, "output/rds/supertree.rds")
#supertree <- readRDS("output/rds/supertree.rds")

# Test
id_success %>%
  dplyr::select(-tree) %>%
  unnest(data)

# Get all taxa combinations
id_combinations <- id_success %>%
  dplyr::select(-tree) %>%
  unnest(data) %>%
  group_by(loci, spp, dataset) %>%
  dplyr::summarise(mono = paste(sort(unique(mono)), collapse = "/"), nn = paste(sort(unique(nn)), collapse = "/"), bcm = paste(sort(unique(bcm)), collapse = "/")) %>%
  mutate(mono = case_when(
    mono == TRUE  ~ "correct",
    mono == FALSE ~ "incorrect",
    str_detect(mono,"/") ~ "mixed"
  ),
  nn = case_when(
    nn == TRUE  ~ "correct",
    nn == FALSE ~ "incorrect",
    str_detect(nn,"/") ~ "mixed"
  ),
  bcm = case_when(
    bcm == "no id"  ~ "incorrect",
    bcm == "ambiguous" ~ "mixed",
    str_detect(bcm,"/") ~ "mixed",
    TRUE ~ bcm
  )) %>%
  ungroup() %>%
  tidyr::complete(loci, spp, fill=list(mono=NA, nn=NA, bcm=NA))%>%
  mutate(genus = spp %>% str_remove(" .*$") %>% str_remove("_.*$"))


# Write out combinations
id_combinations %>%
  ungroup() %>%
  dplyr::select(dataset, loci, spp, mono, nn, bcm) %>%
  mutate(win_length = case_when(
    str_detect(loci, "220") ~ "220bp",
    str_detect(loci, "420") ~ "420bp",
    str_detect(loci, "full") ~ "full",
    TRUE ~ "primer"
  )) %>%
  filter(!is.na(dataset), win_length == "primer") %>%
  dplyr::select(-win_length) %>%
  pivot_longer(cols = c("mono", "nn", "bcm"), 
               names_to = "metric",
               values_to = "value") %>%
  group_by(metric, dataset) %>%
  mutate(value = case_when(
    value == "correct" ~ "TRUE",
    value == "incorrect" ~ "FALSE",
    value == "mixed" ~ "MIXED",
    TRUE ~ "NA"
  )) %>%
  group_split() %>%
  purrr::map(function(x){
    metric <- unique(x$metric)
    dataset <- unique(x$dataset)
    x %>%
      dplyr::select(-metric) %>%
      pivot_wider(names_from = "loci",
                  values_from = "value") %>%
      write_csv(paste0("output/",metric,"_", dataset, "_id.csv"))
    
  })

# Summarsie id combinaations
id_combinations %>%
  distinct()%>%
  group_by(loci) %>%
  mutate(mono = case_when(
    mono=="correct"~TRUE,
    TRUE ~ FALSE
  )) %>%
  summarise(correct = sum(mono), incorrect = sum(!mono ), n =n()) %>%
  mutate(prop = scales::percent(correct / n))

  
# Get all possible combinations of 2 loci  
find_all_combinations <- function(mat, n=2){
  if(n > 1){
    # Get all unique combinations up to N
    comb_mat <- gtools::combinations(n = length(colnames(mat)), r = n, v = colnames(mat), repeats.allowed = FALSE)
    res <- vector("list", length = nrow(comb_mat))
    for (r in 1:nrow(comb_mat)){
      cols_to_subset <- comb_mat[r,]
      subset_mat <- mat[,cols_to_subset]
      
      # Get number of identified taxa
      res[[r]] <- tibble(
        comb = paste0(cols_to_subset, collapse="-"),
        n_id = sum(rowSums(subset_mat) > 0),
        failed=list(rownames(subset_mat)[(rowSums(subset_mat)== 0)])
      )
    }
  } else {
    res <- vector("list", length = ncol(mat))
    for (r in 1:ncol(mat)){
      cols_to_subset <- colnames(mat)[r]
      subset_mat <- mat[,cols_to_subset]
      
      # Get number of identified taxa
      res[[r]] <- tibble(
        comb = paste0(cols_to_subset, collapse="-"),
        n_id = sum(subset_mat > 0),
        failed=list(names(subset_mat)[subset_mat== 0])
      )
    }
  }
  out <- bind_rows(res) %>%
    dplyr::mutate(n_total = nrow(mat))
  return(out)
}
  
all_combinations <- id_combinations %>%
  filter(!is.na(dataset)) %>%
  #filter(genus %in% c("Bactrocera", "Dacus", "Zeugodacus", "Monacrostichus")) %>%
  #filter(genus == "Bactrocera") %>%
  #filter(spp %in% target_list$species) %>%
  dplyr::select(-genus) %>%
  mutate(primer = loci,  
         loci = loci %>% 
           str_remove("_.*$")) %>%
  mutate(win_length = case_when(
    str_detect(primer, "220") ~ "220bp",
    str_detect(primer, "420") ~ "420bp",
    str_detect(primer, "full") ~ "full",
    TRUE ~ "primer"
  )) %>%
  mutate(id = case_when(
    mono == "correct" ~ 1,
    mono == "incorrect" ~ 0,
    mono == "mixed"  ~ 0,
    TRUE ~ 0
  )) %>%
  dplyr::select(-nn, -mono, -bcm) %>%
  distinct() %>%
  ungroup()%>%
  group_by(win_length, dataset) %>%
  dplyr::select(-primer) %>%
  group_modify(~{
    id_matrix <- .x %>%
      #dplyr::select(-win_length, -dataset) %>%
      pivot_wider(names_from = loci,
              values_from = id,
              values_fill = 0) %>%
      column_to_rownames("spp") %>%
      as.matrix()
    bind_rows(find_all_combinations(id_matrix, n=1) %>% mutate(n_comb = 1),
              find_all_combinations(id_matrix, n=2) %>% mutate(n_comb = 2),
              find_all_combinations(id_matrix, n=3) %>% mutate(n_comb = 3),
              find_all_combinations(id_matrix, n=4) %>% mutate(n_comb = 4)
                     )
  })

# Should be able to combine - overlap bars with one colour for full loci and coloured for priemr

fig2_data <- all_combinations %>%
  dplyr::select(-where(is.list)) %>%
  group_by(win_length) %>%
  mutate(prop_id =  n_id / n_total) %>%
  ungroup() %>%
  mutate(dataset = dataset %>% 
           str_replace("all", "Tephritidae")%>% 
           str_replace("dacine", "Dacinae")%>% 
           str_replace("target", "Target lure responders")
         ) %>%
  mutate(dataset = factor(dataset, levels = c("Tephritidae","Dacinae", "Target lure responders" ))) %>%
  mutate(comb = str_replace_all(comb, "-", "+")) %>%
  filter(win_length %in% c("primer", "full")) %>%
  mutate(win_length = win_length %>%
           str_replace("primer", "Amplified region") %>%
           str_replace("full", "Full alignment")) %>%
  mutate(n_comb = paste0(n_comb, "x Loci"))  

gg.fig2 <- fig2_data %>%
  mutate(comb = reorder_within(comb, n_id, within=n_comb)) %>%
  filter(!is.na(dataset)) %>%
  ggplot(aes(x = comb, y = n_id, fill=win_length, group=win_length))+
  geom_col(position="identity") + 
  facet_grid(dataset~n_comb, space="free_x", scales="free", drop=TRUE) +
  scale_x_reordered() +
  base_theme +
  theme(legend.position = "top",
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) + 
  scale_fill_brewer(palette="Set1",direction = -1) +
  labs(x = "Marker combination",
       y = "Species identified",
       fill = "Type:")

gg.fig2

pdf(file= "fig/Fig2_id_combinations.pdf", width = 11, height = 8, paper="a4r")
  plot(gg.fig2)
try(dev.off(), silent=TRUE)
  
# Check which species cant be identified with the full loci

final_failed_id <- all_combinations %>% 
  filter(dataset == "target", comb == "COI-EIF3L", win_length=="primer")%>% 
  unnest(failed)

# plot tree
p1 <- ggtree(supertree, ladderize = TRUE,branch.length = "none") 
  
# Plot heatmap and arrange by tree
library(tidytext)

plot_id_combinations <- id_combinations %>%
  left_join(p1$data %>% dplyr::rename(spp = label)) %>%
  mutate(primer = loci %>%
           str_remove(".fa.gz")%>%
           str_remove(".fa"),  
         loci = loci %>% 
           str_remove("_.*$")) %>%
  group_by(loci, primer) %>%
  mutate(perc_id = sum(nn=="correct",na.rm = TRUE) / sum(!is.na(nn))) %>%
  #mutate(perc_id = sum(mono=="correct",na.rm = TRUE) / sum(!is.na(mono))) %>%
  ungroup() %>%
  mutate(primer = reorder_within(primer,by= -perc_id, within=loci, fun=mean)) %>%
  mutate(loci = factor(loci, levels =c("COI", "EIF3L", "DDOST", "RPA2", "POP4"))) 

gg.id_comb <- plot_id_combinations %>%
  ggplot(aes(x = primer, y = fct_reorder(spp, y), fill=mono)) +
  geom_tile() +
  facet_grid(~loci, scales="free_x", space="free", drop=TRUE) +
  scale_x_reordered()+
  scale_fill_manual(values = c(correct="#66bd63", incorrect="#d73027", mixed = "#ffffbf")) + 
  base_theme +
  labs(x = "Primer set",
       y = NULL)
 
gg.id_multifig_all <- p1 + gg.id_comb + plot_layout(widths = c(1,3))

gg.id_multifig_all

gg.id_dacine <- plot_id_combinations %>%
  filter(genus %in% c("Bactrocera", "Dacus", "Zeugodacus", "Monacrostichus")) %>%
  ggplot(aes(x = primer, y = fct_reorder(spp, y), fill=mono)) +
  geom_tile() +
  facet_grid(~loci, scales="free_x", space="free", drop=TRUE) +
  scale_x_reordered()+
  scale_fill_manual(values = c(correct="#66bd63", incorrect="#d73027", mixed = "#ffffbf")) + 
  base_theme +
  labs(x = "Primer set",
       y = NULL)

gg.id_dacine

gg.id_target <- plot_id_combinations %>%
  filter(spp %in% (target_list$species %>% str_replace(" ", "_"))) %>%
  ggplot(aes(x = primer, y = fct_reorder(spp, y), fill=mono)) +
  geom_tile() +
  facet_grid(~loci, scales="free_x", space="free", drop=TRUE) +
  scale_x_reordered()+
  scale_fill_manual(values = c(correct="#66bd63", incorrect="#d73027", mixed = "#ffffbf")) + 
  base_theme +
  labs(x = "Primer set",
       y = NULL)

gg.id_target

# Facet by genus?
# Do one for just dacinae

pdf(file= "fig/id_combination_all.pdf", width = 8, height = 50)
  plot(gg.id_multifig_all)
try(dev.off(), silent=TRUE)
  
pdf(file= "fig/id_combination_dacine.pdf", width = 8, height = 30)
  plot(gg.id_dacine)
try(dev.off(), silent=TRUE)
  
# I want to find a best combination of 2 columns that maximizes the number on non-0 values per row
# Define function
# Modified from: https://stackoverflow.com/questions/45284082/find-the-best-combination-of-columns-in-a-matrix
# It looks for the column with most non-zeros, removes those rows from the comparison, and repeats. It returns the column numbers of the n best columns.
find_top_combinations <- function(mat, n=2){
  cols <- rep(FALSE,ncol(mat)) #columns to exclude
  rows <- rep(TRUE,nrow(mat)) #rows to include
  for(i in 1:n){
    colsums <- colSums(mat[rows,])
    colsums[cols] <- -1 #to exclude those already accounted for
    maxcol <- which.max(colsums)
    cols[maxcol] <- TRUE
    rows <- rows & !as.logical(mat[,maxcol]) 
  }
  return(which(cols))
}

#Find best 2 combinations of loci - Do this for each length category
best_combinations <- id_combinations %>%
  filter(spp %in% (target_list$species %>% str_replace(" ", "_"))) %>%
  #filter(genus %in% c("Bactrocera", "Dacus", "Zeugodacus", "Monacrostichus")) %>%
  dplyr::select(-genus) %>%
  mutate(primer = loci %>%
           str_remove(".fa.gz")%>%
           str_remove(".fa"),  
         loci = loci %>% 
           str_remove("_.*$")) %>%
  mutate(win_length = case_when(
    str_detect(primer, "220") ~ "220bp",
    str_detect(primer, "420") ~ "420bp",
    str_detect(primer, "full") ~ "full",
    TRUE ~ "primer"
  )) %>%
  mutate(id = case_when(
    mono == "correct" ~ 1,
    mono == "incorrect" ~ 0,
    mono == "mixed"  ~ 0,
    TRUE ~ 0
  )) %>%
  dplyr::select(-nn, -mono, -bcm) %>%
  distinct() %>%
  ungroup() %>%
  group_by(win_length, dataset) %>%
  dplyr::select(-loci) %>%
  group_modify(~{
    id_matrix <- .x %>%
      pivot_wider(names_from = primer,
              values_from = id,
              values_fill = 0) %>%
      column_to_rownames("spp") %>%
      as.matrix()

    # 1 loci
    subset_matrix_1 <- id_matrix[,find_top_combinations(id_matrix, n=1)]
    n_id_1 <- length(unique(names(subset_matrix_1)[subset_matrix_1 == 1]))
    # 2 loci
    subset_matrix_2 <- id_matrix[,find_top_combinations(id_matrix, n=2)]
    n_id_2 <- length(unique(rownames(subset_matrix_2)[rowSums(subset_matrix_2)> 0]))
    # 3 loci
    subset_matrix_3 <- id_matrix[,find_top_combinations(id_matrix, n=3)]
    n_id_3 <- length(unique(rownames(subset_matrix_3)[rowSums(subset_matrix_3)> 0]))
    # 4 loci
    subset_matrix_4 <- id_matrix[,find_top_combinations(id_matrix, n=4)]
    n_id_4 <- length(unique(rownames(subset_matrix_4)[rowSums(subset_matrix_4)> 0]))
    
    tribble(
      ~n_loci, ~comb, ~n_id, ~n_total, ~failed,
      "1", colnames(id_matrix)[find_top_combinations(id_matrix, n=1)], n_id_1, length(unique(names(subset_matrix_1))), names(subset_matrix_1)[subset_matrix_1 == 0],
      "2", paste(colnames(subset_matrix_2), collapse = "/"), n_id_2, length(unique(rownames(subset_matrix_2))), rownames(subset_matrix_2)[rowSums(subset_matrix_2) == 0],
      "3", paste(colnames(subset_matrix_3), collapse = "/"), n_id_3, length(unique(rownames(subset_matrix_3))), rownames(subset_matrix_3)[rowSums(subset_matrix_3) == 0],
      "4", paste(colnames(subset_matrix_4), collapse = "/"), n_id_4, length(unique(rownames(subset_matrix_4))), rownames(subset_matrix_4)[rowSums(subset_matrix_4) == 0]
    )
  })

# Look at gain in accuracy as you add more loci - Do this for each length category
gg.id_bars <- best_combinations %>%
  filter(!is.na(dataset)) %>%
  group_by(win_length, n_loci, dataset) %>%
  mutate(prop_id =  n_id / n_total) %>%
  ungroup() %>%
  filter(!is.na(dataset)) %>%
#  mutate(win_length = win_length %>%
#           factor(levels = c("full", "420bp", "220bp"))) %>% #"320bp",
  mutate(n_loci = as.numeric(n_loci)) %>%
  ggplot(aes(x = fct_reorder(comb, n_loci), y = prop_id, fill = as.factor(n_loci)))+
  geom_col() + 
  geom_text(aes(label=n_id), vjust = -0.5)+
  facet_grid(dataset~win_length, space="free", scales="free_x", drop=TRUE) +
  base_theme + 
  scale_y_continuous(labels= scales::percent_format())+
  scale_fill_brewer(palette="Paired") +
  labs(x = "Marker combination",
       y = "Percentage identified")

gg.id_bars

pdf(file= "fig/id_combination_bars.pdf", width = 11, height = 15)
  plot(gg.id_bars)
try(dev.off(), silent=TRUE)
  
# Find the differences

# look at what species are gained when you add another by each

failed_id_combinations <- best_combinations %>% 
  #unnest_longer(failed) %>%
  mutate(lagged = lag(failed)) %>%
  mutate(gain =  map2(lagged, failed, function(x,y){
    setdiff(x, y)
    }) )

gg.id_heat <- failed_id_combinations %>%
  unnest_longer(gain) %>%
  mutate(win_length = win_length %>%
           factor(levels = c("full", "420bp", "320bp", "220bp"))) %>%
  ggplot(aes(x = fct_reorder(comb, n_loci), y= gain))+
  #geom_tile()+
  geom_text(aes(label=gain))+
  facet_grid(~win_length, space="free", scales="free", drop=TRUE) +
  base_theme + 
  scale_fill_brewer(palette="Paired") +
  labs(x = "Marker combination",
       y = "Percentage identified")
  

gg.id_bars / gg.id_heat

# Look at difference betwene a COI + EIF3L at 420 vs 220 bp
comp1 <- failed_id_combinations %>%
  filter(comb == "COI/EIF3L", win_length == "220bp") %>%
  pull(failed) %>%
  unlist()

comp2 <- failed_id_combinations %>%
  filter(comb == "COI/EIF3L", win_length == "420bp") %>%
  pull(failed) %>%
  unlist()

setdiff(comp1, comp2)
```

# Predicted mismatch

```{r Primerminer, message=FALSE}
# Get mismatch with all
mismatch <- fs::dir_ls(path="diagnostic_alignments/cleaned/", glob = "*.fa*") %>%
  purrr::map(function(x){
    print(x)
    loci_name <- basename(as.character(x)) %>% 
    str_remove("\\..*$")
    
    seqs <- insect::readFASTA(x)
    
    # Get binding position of primers
    model <- readRDS(fs::dir_ls(path="diagnostic_alignments/model", glob = paste0("*",loci_name,"*")))
    primers <- read_csv("primer_candidates.csv")%>%
      dplyr::filter(loci == loci_name, final)%>% 
      select(loci, name = Fname, primer=Fseq) %>%
      left_join(.$primer %>% purrr::map(get_binding_position, model, tryrc = FALSE, min_score=8) %>%
              bind_rows()) %>%
      mutate(dir="F") %>%
      bind_rows( read_csv("primer_candidates.csv")%>%
      dplyr::filter(loci == loci_name, final)%>% 
      select(loci, name = Rname, primer=Rseq) %>%
      left_join(.$primer %>% purrr::map(get_binding_position, model, tryrc = TRUE, min_score=8) %>%
              bind_rows()) %>%
      mutate(dir="R")
      ) 
    
    mismatch <- vector("list", length=nrow(primers))
    for (p in 1:nrow(primers)){
      mismatch[[p]] <- evaluate_primer(seqs, primer = primers$primer[p], positions = c(primers$start[p], primers$end[p]),
                                  direction = ifelse(primers$dir[p] == "F", "F", "R"), gaps = "skip", ambig = "skip",
                                  adjacent = 2, quiet=FALSE) %>%
        mutate(primer = primers$name[p], primer_seq = primers$primer[p])
    }
    
    out <- mismatch %>%
      bind_rows() %>%
      mutate(loci = loci_name)
    return(out)    
  })%>%
  bind_rows()

write_tsv(mismatch, "output/mismatch.tsv")

# all
mismatch %>%
  mutate(genus = template_name %>% str_remove("^.*;") %>%
           str_remove("_.*$")) %>%
  group_by(genus, loci, primer, direction) %>%
  summarise(mismatch = mean(sum, na.rm=TRUE)) %>%
  ungroup() %>%
  filter(!is.na(mismatch)) %>%
  ggplot(aes(x = primer, y = genus, fill=mismatch)) +
  geom_tile() +
  facet_grid(~direction, drop = TRUE, scales="free_x") +
  base_theme

# Dacinae
mismatch %>%
  mutate(genus = template_name %>% str_remove("^.*;") %>%
           str_remove("_.*$"),
         species = template_name %>% str_remove("^.*;")) %>%
  group_by(species,genus, loci, primer, direction) %>%
  summarise(mismatch = mean(sum, na.rm=TRUE)) %>%
  ungroup() %>%
  filter(!is.na(mismatch)) %>%
  filter(genus %in% c("Bactrocera", "Dacus", "Zeugodacus", "Monacrostichus")) %>%
  ggplot(aes(x = primer, y = species, fill=mismatch)) +
  geom_tile() +
  facet_grid(~direction, drop = TRUE, scales="free_x") +
  base_theme

#targets
# Read in target list
#target_list <- readxl::read_xlsx("sample_data/Metabarcoding target list.xlsx") %>%
#  janitor::clean_names() %>%
#  mutate(genus = genus %>% str_remove(" .*$")) %>%
#  mutate(species = paste0(genus, " ", species))

target_list <- readxl::read_xlsx("sample_data/180613 _ALL FF_Lucid Key_NAQS flies.xlsx") %>%
  janitor::clean_names() %>%
  dplyr::select(lure = trap_lure_type, genus, species) %>%
  mutate(genus = genus %>% str_remove(" .*$")) %>%
  mutate(species = paste0(genus, " ", species))

# Targets heatmap
mismatch %>%
  mutate(genus = template_name %>% str_remove("^.*;") %>%
           str_remove("_.*$"),
         species = template_name %>% str_remove("^.*;")) %>%
  group_by(species,genus, loci, primer, direction) %>%
  summarise(mismatch = mean(sum, na.rm=TRUE)) %>%
  ungroup() %>%
  group_by(loci, primer, direction) %>%
  mutate(mean_mm = mean(mismatch, na.rm=TRUE)) %>%
  ungroup() %>%
  mutate(primer = reorder_within(primer, mean_mm, direction)) %>%
  filter(!is.na(mismatch)) %>%
  filter(species %in% (target_list$species %>% str_replace_all(" ", "_"))) %>%
  ggplot(aes(x = primer, y = species, fill=mismatch)) +
  geom_tile() +
  facet_grid(~direction, drop = TRUE, scales="free_x") +
  scale_x_reordered()+
  scale_fill_viridis_c(trans=scales::pseudo_log_trans(10), option = "B", limits=c(0,1000), oob=scales::squish)+
  base_theme +
  theme(legend.position = "right") +
  labs(x = "Primer",
       y = "Target species",
       fill = "Mismatch \npenalty")

library(ggradar)

gg.radar_f <- mismatch %>%
  mutate(genus = template_name %>% str_remove("^.*;") %>%
           str_remove("_.*$"),
         species = template_name %>% str_remove("^.*;")) %>%
  filter(direction == "F") %>%
  filter(genus %in% c("Bactrocera", "Dacus", "Zeugodacus", "Monacrostichus")) %>%
  group_by(genus, primer) %>%
  summarise(mismatch = mean(sum, na.rm=TRUE)) %>%
  ungroup() %>%
  pivot_wider(names_from = genus,
              values_from = mismatch,
              values_fill=list(mismatch=0))%>%
  mutate_at(vars(-primer), function(x) {1-scales::rescale(x)}) %>%
  ggradar()  +
  theme(legend.position = "bottom")+
  guides(fill=guide_legend(nrow=2,byrow=TRUE)) + 
  ggtitle("Reverse primers")

gg.radar_r <- mismatch %>%
  mutate(genus = template_name %>% str_remove("^.*;") %>%
           str_remove("_.*$"),
         species = template_name %>% str_remove("^.*;")) %>%
  filter(direction == "R") %>%
  filter(genus %in% c("Bactrocera", "Dacus", "Zeugodacus", "Monacrostichus")) %>%
  group_by(genus, primer) %>%
  summarise(mismatch = mean(sum, na.rm=TRUE)) %>%
  ungroup() %>%
  pivot_wider(names_from = genus,
              values_from = mismatch,
              values_fill=list(mismatch=0))%>%
  mutate_at(vars(-primer), function(x) {1-scales::rescale(x)}) %>%
  ggradar()  +
  theme(legend.position = "bottom")+
  guides(fill=guide_legend(nrow=2,byrow=TRUE)) + 
  ggtitle("Reverse primers")

gg.fig3 <- gg.radar_f - gg.radar_r

pdf(file= "fig/Fig3_mismatch_radar.pdf", width = 11, height = 8, paper="a4r")
  plot(gg.fig3)
try(dev.off(), silent=TRUE)
```


# Impute missing

```{r imputation}
# Arrange on tree
tree <- readRDS("output/rds/supertree.rds") 
tree$tip.label <- tree$tip.label %>% str_remove("^.*;")

# Filter summaries to just those in tree
mismatch_summaries <- mismatch %>% 
  mutate(species = template_name %>% str_remove("^.*;")) %>%
  dplyr::filter(species %in% (tree$tip.label)) %>%
  group_by(species, primer, direction) %>%
  summarise(values = mean(sum, na.rm=TRUE))

## Get values for higher nodes with castor
uprimers <- unique(mismatch_summaries$primer)
p_weights <- vector("list", length=length(uprimers))
names(p_weights) <- uprimers

for (i in 1:length(uprimers)){
  print(paste0("Processing Primer ",i, " of ", length(uprimers), ": ", uprimers[i]))
  # Prune tree to tips
  tips_to_keep <- tree$tip.label %>% 
    enframe(name=NULL, value="tips") %>% 
    filter(tips %in% (mismatch_summaries %>% 
                        filter(primer==uprimers[i]) %>%
                        pull(species))) %>%
    distinct()
  
  #Get subtree of only genera
  pruned_tree  <- castor::get_subtree_with_tips(tree,
                                            only_tips = unique(tips_to_keep$tips),
                                            collapse_monofurcations=TRUE,
                                            force_keep_root=TRUE)$subtree
  
  Ntips 	<- length(pruned_tree$tip.label)
  Nnodes 	<- pruned_tree$Nnode
  cat(sprintf("Tree has %d nodes, %d tips and %d edges\n",Nnodes,Ntips,nrow(pruned_tree$edge)));
  
  # create internal node labels
  pruned_tree$node.label <- NA
  if(is.na(pruned_tree$node.label)){
  	cat(sprintf("Adding node labels to full tree..\n"))
  	pruned_tree$node.label = paste("node.", 1:Nnodes, sep = "") # don't use underscores, because some tree readers (e.g. rncl) interpret them as spaces
  }
  
  # replace zero-length edges
  if(any(pruned_tree$edge.length==0)){
    epsilon = 0.1*min(pruned_tree$edge.length[pruned_tree$edge.length>0])
  	cat(sprintf("Note: Some edges have length zero, which may break some of the HSP routines. Replacing zero-lengths with a tiny positive length (%g)..\n",epsilon))
  	pruned_tree$edge.length[pruned_tree$edge.length==0] = epsilon
  }
    
  tip_states <- mismatch_summaries %>%
    dplyr::filter(primer==uprimers[i], species %in% tips_to_keep$tips) %>%
    column_to_rownames("species")
    
  #pruned_tree$tip.label[!pruned_tree$tip.label %in% rownames(tip_states)]
  
  row2tip <- match(rownames(tip_states), pruned_tree$tip.label)
  
  #find non matching
  rownames(tip_states)[is.na(row2tip)]
  
  tip_states <- tip_states[!is.na(row2tip),,drop = FALSE]
  hsp_states <- castor::hsp_independent_contrasts(tree = pruned_tree,
                                              tip_states = tip_states$values,
                                              weighted = FALSE,
                                              check_input = TRUE)$states
  
  # Get distance of each tip to tips that have data
  target_tips <- match(tip_states %>% filter(!is.na(values)) %>% rownames(), pruned_tree$tip.label);
  tip_dist <- castor::find_nearest_tips(pruned_tree, only_descending_tips=FALSE, 
                                        target_tips=target_tips, as_edge_counts=FALSE, check_input=TRUE)
  
   p_weights[[i]] <- tip_states %>%
    rownames_to_column("species") %>%
    mutate(hsp = hsp_states[1:Ntips],
           tip_dist =tip_dist$nearest_distance_per_tip[1:Ntips])
}

imputed <- mismatch_summaries %>%
  ungroup() %>%
    left_join(bind_rows(p_weights,.id = "primer") %>% dplyr::select(-values))%>%
  filter(!is.na(hsp))


gg.radar_imputed_f <- imputed %>%
  mutate(genus = species  %>%
           str_remove(" .*$")%>%
           str_remove("_.*$")) %>%
  filter(direction == "F") %>%
  filter(genus %in% c("Bactrocera", "Dacus", "Zeugodacus", "Monacrostichus")) %>%
  group_by(genus, primer) %>%
  summarise(mismatch = mean(hsp, na.rm=TRUE)) %>%
  ungroup() %>%
  pivot_wider(names_from = genus,
              values_from = mismatch,
              values_fill=list(mismatch=0))%>%
  mutate_at(vars(-primer), function(x) {1-scales::rescale(x)}) %>%
  ggradar() +
  theme(legend.position = "bottom")+
  guides(fill=guide_legend(nrow=2,byrow=TRUE))+ 
  ggtitle("Forward primers")

gg.radar_imputed_r <- imputed  %>%
  mutate(genus = species  %>%
           str_remove(" .*$")%>%
           str_remove("_.*$")) %>%
  filter(direction == "R") %>%
  filter(genus %in% c("Bactrocera", "Dacus", "Zeugodacus", "Monacrostichus")) %>%
  group_by(genus, primer) %>%
  summarise(mismatch = mean(hsp, na.rm=TRUE)) %>%
  ungroup() %>%
  pivot_wider(names_from = genus,
              values_from = mismatch,
              values_fill=list(mismatch=0))%>%
  mutate_at(vars(-primer), function(x) {1-scales::rescale(x)}) %>%
  ggradar()  +
  #scale_color_brewer(palette="Set1") +
  theme(legend.position = "bottom")+
  guides(fill=guide_legend(nrow=2,byrow=TRUE)) + 
  ggtitle("Reverse primers")

gg.radar_imputed_f - gg.radar_imputed_r


pdf(file= "fig/imputed_mismatch_radar.pdf", width = 11, height = 8, paper="a4r")
  plot(gg.radar_imputed_f)
  plot(gg.radar_imputed_r)
try(dev.off(), silent=TRUE)
  
```

# Compare imputation
Compare imputign scores from tree, vs imputing sequences then calculating scores

Steps:
- get known outcomes by filtering to only complete sequences and calculating scores
- Randomly Drop out the entire binding positions (or part of binding positions) for a subset of known sequences (10%?)
- Impute sequence data then calculate scores OR calculate scores then impute scores
- Compare RMSE between the known and imptued data


```{r}

seqs <- insect::readFASTA("diagnostic_alignments/cleaned/COI.fa.gz")

# Make full distance matrix
datd <- DECIPHER::DistanceMatrix(DNAbin2DNAstringset(seqs), includeTerminalGaps = FALSE, penalizeGapLetterMatches = TRUE,
                                 penalizeGapGapMatches = FALSE, correction = "Jukes-Cantor", processors = 1, verbose = TRUE)

tree <- bionjs(datd)

# Get binding position of primers
model <- readRDS("diagnostic_alignments/model/Bactrocera_COI.rds")

primers <- read_csv("primer_candidates.csv")%>%
  dplyr::filter(loci == loci_name)%>% 
  select(loci, name = Fname, primer=Fseq) %>%
  left_join(.$primer %>% purrr::map(get_binding_position, model, tryrc = FALSE, min_score=8) %>%
          bind_rows()) %>%
  mutate(dir="F") %>%
  bind_rows( read_csv("primer_candidates.csv")%>%
  dplyr::filter(loci == loci_name)%>% 
  select(loci, name = Rname, primer=Rseq) %>%
  left_join(.$primer %>% purrr::map(get_binding_position, model, tryrc = TRUE, min_score=8) %>%
          bind_rows()) %>%
  mutate(dir="R")
  ) 
    
set.seed(666)
mismatch_rmse <- vector("list", length=nrow(primers))
for (p in 1:nrow(primers)){

  # Calculate the mismatch for the full known seqs
  known_mismatch <- evaluate_primer(seqs, primer = primers$primer[p], positions = c(primers$start[p], primers$end[p]),
                             direction = ifelse(primers$dir[p] == "F", "F", "R"), gaps = "skip", ambig = "skip",
                             adjacent = 2, quiet=FALSE) %>%
   mutate(primer = primers$name[p], primer_seq = primers$primer[p])
  
  # Delete a random 10% within the binding regions
  to_delete <- sample(seq(1, length(seqs),1), round(length(seqs)/2), replace = FALSE)
  eval_seqs <- as.matrix(seqs)
  eval_seqs[to_delete, primers$start[p]:primers$end[p]] <- as.raw(00)
  
  # Calculate the mismatch for the full known seqs
  imputed_mismatch <- evaluate_primer(as.list(eval_seqs), primer = primers$primer[p], positions = c(primers$start[p], primers$end[p]),
                             direction = ifelse(primers$dir[p] == "F", "F", "R"), gaps = "impute", ambig = "impute",
                             adjacent = 2, quiet=FALSE, tree=tree) %>%
   mutate(primer = primers$name[p], primer_seq = primers$primer[p]) 
  
  # Calculate RMSE for just the imputed ones
  eval_mismatch <- known_mismatch[to_delete,] %>%
    dplyr::select(template_name, known_seq = template_seq, known_mm = sum, primer) %>%
    left_join(imputed_mismatch[to_delete,]%>%
    dplyr::select(template_name, imputed_seq = template_seq, impute_mm = sum, primer)) 
  
  eval_rmse1 <- eval_mismatch %>%
    rmse(truth = known_mm, estimate=impute_mm) %>%
    dplyr::select(rmse1 = .estimate)
  
  
  # Alternatively - Impute the mismatch scores rather than the sequence
  unimputed_mismatch <- evaluate_primer(as.list(eval_seqs), primer = primers$primer[p], positions = c(primers$start[p], primers$end[p]),
                             direction = ifelse(primers$dir[p] == "F", "F", "R"), gaps = "skip", ambig = "skip",
                             adjacent = 2, quiet=FALSE, tree=tree) %>%
   mutate(primer = primers$name[p], primer_seq = primers$primer[p]) 
  
  # Impute mismatch score 
  
  #Get subtree of only genera
  pruned_tree  <- castor::get_subtree_with_tips(tree,
                                            only_tips = names(eval_seqs),
                                            collapse_monofurcations=TRUE,
                                            force_keep_root=TRUE)$subtree
  
  Ntips 	<- length(pruned_tree$tip.label)
  Nnodes 	<- pruned_tree$Nnode

  # create internal node labels
  pruned_tree$node.label <- NA
  if(is.na(pruned_tree$node.label)){
  	pruned_tree$node.label = paste("node.", 1:Nnodes, sep = "") # don't use underscores, because some tree readers (e.g. rncl) interpret them as spaces
  }
  # replace zero-length edges
  if(any(pruned_tree$edge.length==0)){
    epsilon = 0.1*min(pruned_tree$edge.length[pruned_tree$edge.length>0])
  	pruned_tree$edge.length[pruned_tree$edge.length==0] = epsilon
  }
    
  tip_states <- unimputed_mismatch %>%
    column_to_rownames("template_name") %>%
    dplyr::select(values  = sum)
    
  row2tip <- match(rownames(tip_states), pruned_tree$tip.label)
  
  tip_states <- tip_states[!is.na(row2tip),,drop = FALSE]
  hsp_states <- castor::hsp_independent_contrasts(tree = pruned_tree,
                                              tip_states = tip_states$values,
                                              weighted = FALSE,
                                              check_input = TRUE)$states
  imputed_states <- tip_states %>%
    mutate(impute_mm = hsp_states[1:Ntips])
  
  eval_mismatch2 <- known_mismatch[to_delete,] %>%
    dplyr::select(template_name, known_seq = template_seq, known_mm = sum, primer) %>%
    left_join(imputed_states[to_delete,]%>%
                rownames_to_column("template_name") %>%
    dplyr::select(template_name,impute_mm)) 
  
  eval_rmse2 <- eval_mismatch2 %>%
    rmse(truth = known_mm, estimate=impute_mm) %>%
    dplyr::select(rmse2 = .estimate)
  
  mismatch_rmse[[p]] <- bind_cols(eval_rmse1, eval_rmse2)
  
  # Imputing states seems to be more accurate?
  
  # Evaluate different imputing algorithms?
  
  # Do the resamples in phylogenetic distance bins?
  
}



```



# Create reference databases 

```{r filter seqs}
db <- taxreturn::get_ncbi_taxonomy()
ncores <- 3
set.seed(666)

#x <- fs::dir_ls(path="diagnostic_alignments/merged", glob = "*.fa.gz*")[[1]]
to_remove <- readLines("diagnostic_alignments/mislabelled.txt")

dir.create("reference")

filt <- c("diagnostic_alignments/cleaned/COI.fa.gz",
          "diagnostic_alignments/cleaned/EIF3L.fa.gz") %>%
  purrr::map(function(x){
    loci_name <- basename(as.character(x)) %>% 
      str_remove("\\..*$")
    
    seqs <- insect::readFASTA(x)
    names(seqs) <- names(seqs) %>% str_replace_all(" ", "_")
    
    #load phmm
    model <- readRDS(fs::dir_ls(path="diagnostic_alignments/model", glob = paste0("*",loci_name,"*")))
    
    # Trim model to primers
    if(loci_name == "COI"){
      model <- subset_model(model, primers = c("GGDACWGGWTGAACWGTWTAYCCHCC", "GTRATWGCHCCDGCTARWACWGG"), trimprimers = TRUE)
    } else if (loci_name == "EIF3L"){
      model <- subset_model(model, primers = c("GATGCGYCGTTATGCYGATGC", "TTRAAYACTTCYARATCRCC"), trimprimers = TRUE)
    }
    
    # Align to phmm
    filtered <- taxreturn::map_to_model(seqs,  model, min_score = 100,
     shave=TRUE, trim_ends = 4, check_frame=TRUE,  max_N = 5, max_gap=(model$size/3), extra="drop",
     kmer_threshold = 0.3, k = 5,
     multithread=ncores, quiet=FALSE, progress = FALSE)
    
    insect::writeFASTA(seqs, file=paste0("reference/", loci_name, ".fa.gz"), compress=TRUE)
    
    
    seqs_ref <- reformat_hierarchy(seqs, db = db)
    
    lineage <- names(seqs_ref)%>% 
                stringr::str_split_fixed(";", n = Inf) %>% 
                  tibble::as_tibble() %>%
      magrittr::set_colnames(c("acc", "kingdom", 
        "phylum", "class", "order", "family", 
        "genus", "species")) %>%
      na_if("NA") 
    
    # Fill in missing
    missing_fill <- lineage %>%
      dplyr::select(acc, genus, species) %>%
      filter(is.na(genus)) %>%
      mutate(genus = str_remove(species, "_.*$")) %>%
      left_join(db %>% dplyr::select(c("kingdom", 
        "phylum", "class", "order", "family", 
        "genus")) %>% distinct())
      
    # coalesce join with the unqiue ones
    names(seqs_ref) <- lineage %>%
      dplyr::rows_update(missing_fill)  %>%
      tidyr::unite(col = "names", c("acc", "kingdom", 
        "phylum", "class", "order", "family", 
        "genus", "species"), sep = ";") %>%
      pull(names)
    
    # Write out refernce sets
    names(seqs_ref) <- names(seqs_ref) %>% str_replace_all("_", " ")
    insect::writeFASTA(seqs_ref, file=paste0("reference/", loci_name, "_hierarchial.fa.gz"), compress=TRUE)
      
    # Train IDTAXA
    training_set <- train_idtaxa(
      seqs_ref, max_group_size = 10, max_iterations = 3,  
      allow_group_removal = TRUE,  get_lineage = FALSE, quiet = FALSE
      )
    
    #Write out training set
    dir.create("reference")
    saveRDS(training_set, file=paste0("reference/", loci_name, "_idtaxa.rds"))

})%>%
  bind_rows()


#write_csv(filt, "filter_stats_amplicon.csv")

target_list <- readxl::read_xlsx("sample_data/primer_identifications_MKS_JR_MLS.xlsx") %>%
  janitor::clean_names() %>%
  dplyr::select(lure = x2, species = spp)  %>%
  mutate(species = species %>% str_replace_all(" ", "_")) %>%
  mutate(species = species %>% str_replace("Bactrocera_sp._nr._quadrata", "Bactrocera_nr.quadrata"))%>%
  mutate(species = species %>% str_replace("Bactrocera_tenufascia", "Bactrocera_tenuifascia"))

filt <- read_csv("filter_stats_amplicon.csv")


test <- target_list %>% 
  left_join(filt)


filt %>%
  pivot_longer(-loci,
               names_to="step",
               values_to="seqs") %>%
  mutate(step = factor(step, levels=c("seqs", "uniqseqs", "namefilt", "phmm", "codonfilt", "purged"))) %>%
  ggplot(aes(x = step, y = seqs))+
  geom_col()+
  facet_grid(loci~., scales="free_y")

```


# Check presence of targets

```{r}


# Counts after filtering, and write out 
cleaned_counts <- target_list %>%
  left_join(fs::dir_ls(path="diagnostic_alignments/reference", glob = "*.fa.gz") %>%
  purrr::map_dfr(function(x){
  print(x)
  seqs <- insect::readFASTA(x)
  names(seqs) <- names(seqs) %>% str_replace_all(" ", "_")
  loci_name <- basename(as.character(x)) %>% 
    str_remove("\\..*$")
    
  spp <- tibble::enframe(names(seqs), name=NULL, value="species") %>%
    mutate(species = species %>% str_remove("^.*;")) %>%
    group_by(species) %>%
    summarise(n = n()) %>%
    mutate(loci = loci_name)
})) %>%
  tidyr::pivot_wider(names_from = loci,
                     values_from = n,
                     values_fill = list(n=0)) %>%
  dplyr::select(-`NA`)

cleaned_counts %>% 
  mutate(COI = case_when(
    COI > 10 ~ as.integer(10),
    TRUE ~ as.integer(COI)
  ),
  EIF3L = case_when(
    EIF3L > 10 ~ as.integer(10),
    TRUE ~ as.integer(EIF3L)
  )) %>%
  write_csv("cleaned_counts.csv")


# Orignal counts before filtering
merged_counts <- target_list %>%
  left_join(fs::dir_ls(path="diagnostic_alignments/merged", glob = "*.fa.gz") %>%
  purrr::map_dfr(function(x){
  print(x)
  seqs <- insect::readFASTA(x)
  names(seqs) <- names(seqs) %>% str_replace_all(" ", "_")
  loci_name <- basename(as.character(x)) %>% 
    str_remove("\\..*$")%>% 
    str_remove("_merged")
    
  spp <- tibble::enframe(names(seqs), name=NULL, value="species") %>%
    mutate(species = species %>% str_remove("^.*;")) %>%
    group_by(species) %>%
    summarise(n = n()) %>%
    mutate(loci = loci_name)
})) %>%
  tidyr::pivot_wider(names_from = loci,
                     values_from = n,
                     values_fill = list(n=0)) %>%
  dplyr::select(-`NA`)


# Find ones removed by filtering
spp_filtered_out <- (merged_counts %>%
  dplyr::select(-genus, -lure) %>%
  distinct() %>%
  column_to_rownames("species") >0
  ) - (cleaned_counts %>%
  dplyr::select(-genus, -lure) %>%
  distinct() %>%
  column_to_rownames("species") >0 ) %>%
  as.data.frame() %>%
  dplyr::select(COI, EIF3L)

spp_filtered_out <- spp_filtered_out[rowSums(spp_filtered_out) > 0,]


# Get all witho

# Need to check why they were filtered

# Check which ones are covered by pblic sequencs
```

# make some alignments of just targets

```{r}

target_list <- readxl::read_xlsx("sample_data/primer_identifications_MKS_JR_MLS.xlsx") %>%
  janitor::clean_names() %>%
  dplyr::select(lure = x2, species = spp)  %>%
  mutate(species = species %>% str_replace_all(" ", "_")) %>%
  mutate(species = species %>% str_replace("Bactrocera_sp._nr._quadrata", "Bactrocera_nr.quadrata"))%>%
  mutate(species = species %>% str_replace("Bactrocera_tenufascia", "Bactrocera_tenuifascia"))


dir.create("diagnostic_alignments/cleaned/targets")

fs::dir_ls(path="diagnostic_alignments/cleaned/", glob = "*.fa.gz")%>%
  purrr::map(function(x){
    loci_name <- basename(as.character(x)) %>% 
      str_remove("_.*$")
    
    seqs <- insect::readFASTA(x)
    names(seqs) <- names(seqs) %>% str_replace_all(" ", "_")
   
    subset_seqs <- seqs[(names(seqs)  %>% str_remove("^.*;")) %in% target_list$species]
    insect::writeFASTA(subset_seqs, paste0("diagnostic_alignments/cleaned/targets/",loci_name))
})



```

# Sequence logos

```{r Create sequence logos}
library(ggseqlogo)

seq_logos <- fs::dir_ls(path="diagnostic_alignments/cleaned", glob = "*.fa") %>%
  purrr::map(function(x){
    seqs <- dna2char(insect::readFASTA(x))
    ggplot() + 
      geom_logo(seqs) + 
      theme_logo() +
      labs(title = x %>% 
             str_remove("_aligned.*$") %>%
             str_remove("^.*/")) +
      scale_x_continuous(expand=c(0,0), breaks = seq(0, max(sapply(seqs, nchar)), 10))+
      scale_y_continuous(expand=c(0,0))
  })

gg.seq_logos <- wrap_plots(seq_logos, ncol=1)


pdf(file="fig/seq_logos.pdf", width = 50, height = 8)
  plot(gg.seq_logos)
try(dev.off(), silent=TRUE)

```


## SW gifs

```{r sw gif}
# Make directory for gifs
dir.create("gifs")

# Set window parameters
win_length <- 220
win_int <- 20

fs::dir_ls(path="diagnostic_alignments/cleaned", glob = "*.fa") %>%
  purrr::map(function(x){
  print(x)
  seqs <- insect::readFASTA(x)
  
  loci_name <- x %>% str_remove(".*/") %>% str_remove("_.*$")

  spp_names <- names(seqs) %>%
    str_remove("_*(?!.*_).*$") 
  
  # Sliding window analyses
  dat <- as.matrix(seqs)
  dimnames(dat)[[1]] <- spp_names
  
  # Make full distance matrix
  datd <- dist.dna(dat, pairwise.deletion = TRUE)

  # Create windows
  win <- slidingWindow(dat, width=win_length, interval = win_int)
  pos_out <- sapply(win, function(x) attr(x, "window")[1])
  
  # Create distance matrices for each window
  win_dist <- lapply(win, function(x) dist.dna(x, pairwise.deletion = TRUE))

  ## Make NJ trees for each window
  win_tr <- purrr::map2(win_dist,pos_out, function(y,z){
    print(z)
    # Filter out comparisons that are only NA
    y <- as.matrix(y)
    y <- y[rowSums(y, na.rm = TRUE) > 0, colSums(y, na.rm = TRUE) > 0]
    tree <- njs(y)
    
    if(!all(is.finite(tree$edge.length))) {return(NULL)}

     p1 <- ggtree(tree)    
    
    # Highlight monophyletic taxa
    mono <- p1$data %>% 
      left_join(data.frame( label = unique(spp_names),
                        mono = monophyly(tree, spp_names)), by="label")
    p2 <- p1 %<+% mono + 
      geom_tippoint(aes(colour=mono)) +
      theme(legend.position = "top")+
      labs(colour = "Monophyletic",
           title = loci_name) +
      scale_colour_manual(values=c("#e41a1c","#4daf4a"))
    
    # Create SW visualisation
    sw_plot <- enframe(seq(1,ncol(dat), 1), name = NULL, value="pos") %>%
      mutate(in_win = between(pos, z, z+ win_length)) %>%
      ggplot(aes(x = pos, y = 1, fill=in_win)) +
      geom_tile() +
      scale_x_continuous(expand=c(0,0), breaks = seq(0, ncol(dat), 50))+
      scale_y_continuous(expand=c(0,0)) +
      scale_fill_manual(values = c("grey80","firebrick"))+
      theme(axis.text.y  = element_blank(),
            axis.ticks.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "none") +
      labs(x = "Nucleotide position")
      
    out <- p2 / sw_plot + plot_layout(heights = c(20,1))
    
    return(out)
  })
  
 # Remove failed plots
 win_tr <- win_tr[!sapply(win_tr, is.null)]

 out_name <- normalizePath(paste0("gifs/", loci_name ,"_windows.gif"))
 
 # Plot gif
 animation::saveGIF(
   expr = {
    purrr::walk(win_tr, ~{
      plot(.x)
    })
   },
   movie.name = out_name,
   ani.width=620 ,
   ani.height=877,
   interval=2,
   autobrowse=FALSE
 )
 try(dev.off(), silent=TRUE)
  
})

```
