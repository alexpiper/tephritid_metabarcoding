---
title: "Qfly metabarcoding"
subtitle: "Primer design"
author: "Alexander Piper"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Introduction

# Load packages
```{r setup}
#Set required packages
.cran_packages <- c("usethis",
                    "tidyverse",
                    "tidymodels",
                    "spider", 
                    "insect",
                    "ape",
                    "RColorBrewer",
                    "seqinr",
                    "patchwork",
                    "ShortRead",
                    "foreach",
                    "doParallel",
                    "TmCalculator",
                    "castor",
                    "phangorn",
                    "furrr")

.bioc_packages <- c("DECIPHER",
                    "ggtree",
                    "Biostrings")

.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
   install.packages(.cran_packages[!.inst])
}
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install(.bioc_packages[!.inst], ask = F)
}

#Load all packages
sapply(c(.cran_packages,.bioc_packages), require, character.only = TRUE)

# Github packages
devtools::install_github("alexpiper/taxreturn")
library(taxreturn)
library(PrimerMiner)

# SOurce internal functions
source("R/themes.R")
source("R/helper_functions.R")
```

# Download public reference sequences

```{R}
## Fetch tephritid sequences from GenBank
dir.create("diagnostic_alignments/public")
# COI
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="COI[GENE] OR COX1[GENE] OR COXI[GENE] OR cytochrome c oxidase subunit 1", output = "gb-binom", compress=TRUE, force=TRUE, multithread =FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_COI_COX1_COXI_cytochrome_c_oxidase_subunit_1.fa.gz", "diagnostic_alignments/public/Tephritidae_COI_genbank.fa.gz")

# EIF3L (eukaryotic translation initiation factor 3 subunit L)
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="eukaryotic translation initiation factor 3 subunit L", output = "gb-binom", compress=TRUE, force=TRUE, multithread =FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_eukaryotic_translation_initiation_factor_3_subunit_L.fa.gz", "diagnostic_alignments/public/Tephritidae_EIF3L_genbank.fa.gz")

# DDOST2 (dolichyl-diphosphooligosaccharide-protein glycosyltransferase subunit 2)
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="dolichyl-diphosphooligosaccharide-protein glycosyltransferase subunit 2", output = "gb-binom", compress=TRUE, force=TRUE, multithread =FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_dolichyl-diphosphooligosaccharide-protein_glycosyltransferase_subunit_2.fa.gz", "diagnostic_alignments/public/Tephritidae_DDOST2_genbank.fa.gz")

# POP4 (ribonuclease P protein subunit p29)
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="ribonuclease P protein subunit p29", output = "gb-binom", compress=TRUE, force=TRUE, multithread =FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_ribonuclease_P_protein_subunit_p29.fa.gz", "diagnostic_alignments/public/Tephritidae_POP4_genbank.fa.gz")

# RPA2 (replication protein A 32 kDa subunit)
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="replication protein A 32 kDa subunit", output = "gb-binom", compress=TRUE, force=TRUE, multithread =FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_replication_protein_A_32_kDa_subunit.fa.gz", "diagnostic_alignments/public/Tephritidae_RPA2_genbank.fa.gz")

# Fetch tephritid sequences from BOLD

## Fetch sequences from BOLD by searching for a taxon name
fetchSeqs("Tephritidae", database="bold", out.dir="diagnostic_alignments/public", downstream=FALSE, marker="COI-5P", output = "gb-binom", compress=TRUE, force=TRUE, multithread = FALSE)
file.rename("diagnostic_alignments/public/Tephritidae_COI-5P.fa.gz", "diagnostic_alignments/public/Tephritidae_COI_bold.fa.gz")


# Fetch tephritid mitogenomes from genbank
fetchSeqs("Tephritidae", database="genbank", out.dir="diagnostic_alignments/public", quiet=FALSE, marker="mitochondria", output = "gb-binom", compress=TRUE, multithread=FALSE, force=TRUE)


# Fetch tephritid sequences from recent papers
# Not published yet: https://www.biorxiv.org/content/10.1101/2020.11.23.394510v1
```

# Reformat inhouse seuqence names

```{r reformat inhouse}

# Get NCBI reference database
db <- taxreturn::get_ncbi_lineage()

dir.create("diagnostic_alignments/inhouse")
fs::dir_ls(path="diagnostic_alignments", glob = "*Bactrocera_*.fa*|*Melissa*.fa*") %>%
  purrr::map(function(x){
    seqs <- readDNAStringSet(x)
    new_names <- names(seqs) %>%
      trimws() %>%
      str_replace("sp._near_", "nr.")%>%
      str_replace("near_", "nr.")%>%
      str_remove("complex_")%>%
      str_remove("with_medial_spot_")%>%
      str_remove("_$")%>%
      str_split_fixed(pattern="_", n=3) %>%
      as.data.frame() %>%
      mutate(acc = na_if(V3, ""))%>%
      tidyr::unite(V1, V2, col="tax_name", sep = " ") %>%
      left_join(db) %>%
      dplyr::select(acc, tax_id, tax_name) %>%
      tidyr::unite(acc, tax_id,col="acc", sep="|") %>%
      tidyr::unite(acc, tax_name, col="names", sep=";") %>%
      pull(names)

    names(seqs) <- new_names
    writeXStringSet(seqs, filepath = paste0("diagnostic_alignments/inhouse/", basename(as.character(x))))
  })

```


# Create PHMMs

Use only the validated diagnostic allignments to make the PHMMS

```{r create PHMMS}
dir.create("diagnostic_alignments/model")
fs::dir_ls(path="diagnostic_alignments", glob = "*Bactrocera_*.fa") %>%
  purrr::map(function(x){
    # Align all sequences
    aligned <- readDNAStringSet(x) %>%
      replaceAmbiguities("-") %>%
      RemoveGaps()%>%
      AlignSeqs()
    
    # Filter short sequences
    aligned <- aligned[letterFrequency(aligned, "ACGT") > 200]
    
    # Filter for stop codons
    aligned <- taxreturn::codon_filter(aligned)
    
    #Write out aligned sequences
    #writeXStringSet(aligned, filepath= x %>% str_replace_all("merged", "aligned"), append=TRUE, width=20000)
  
    # Create PHMM
    model <- aphid::derivePHMM(as.DNAbin(aligned))
    saveRDS(model, paste0(dirname(as.character(x)), "/model/", basename(as.character(x)) %>% str_replace(".fa", ".rds") %>% str_replace(".fa.gz", ".rds")))
    
})
```


# Merge all sequences

Going to need t ofix fthe formatting of the inhouse ones

```{r merge alignments}
dir.create("diagnostic_alignments/merged")

# Merge sequences function
merge_seqs <- function(path, glob, out){
  if(file.exists(out)){file.remove(out)}
  file.create(out)
  files <- fs::dir_ls(path=path, glob = glob) 
  message("merging ", length(files), " fasta files")
  files %>%
  purrr::map(readDNAStringSet) %>%
  purrr::map(writeXStringSet, filepath=out, append=TRUE, width=20000)
}

#COI
merge_seqs(path=c("diagnostic_alignments/inhouse","diagnostic_alignments/public"), glob="*COI*.fa*|*mitochondria*.fa*", out = "diagnostic_alignments/merged/COI_merged.fa")
  
# EIF3L
merge_seqs(path=c("diagnostic_alignments/inhouse","diagnostic_alignments/public"), glob="*EIF3L*.fa*", out = "diagnostic_alignments/merged/EIF3L_merged.fa")

# DDOST
merge_seqs(path=c("diagnostic_alignments/inhouse","diagnostic_alignments/public"), glob="*DDOST*.fa*", out = "diagnostic_alignments/merged/DDOST_merged.fa")

# POP4
merge_seqs(path=c("diagnostic_alignments/inhouse","diagnostic_alignments/public"), glob="*POP4*.fa*", out = "diagnostic_alignments/merged/POP4_merged.fa")

# RPA2
merge_seqs(path=c("diagnostic_alignments/inhouse","diagnostic_alignments/public"), glob="*RPA2*.fa*", out = "diagnostic_alignments/merged/RPA2_merged.fa")

# fix names and filter
alignments_cleaned <- fs::dir_ls(path="diagnostic_alignments/merged/", glob = "*.fa") %>%
  purrr::map(readDNAStringSet) %>%
  purrr::map(~{
    new_names <- names(.x) %>%
      str_replace_all("Bactrocera_unitaeneola", "Bactrocera_unitaeniola") %>%
      str_replace_all("Bactrocera_calendoniensis", "Bactrocera_caledoniensis") %>%
      str_replace_all("Zeugodacus_platumus", "Zeugodacus_platamus")%>%
      str_replace_all("Bactrocera_erubsecentis", "Bactrocera_erubescentis") %>%
      trimws()
    names(.x) <- new_names
    return(.x)
  }) 
  
alignments_cleaned %>%
  purrr::map2(names(alignments_cleaned), function(x,y){
    writeXStringSet(x, filepath=y, append=FALSE, width=20000)
  })

```

# Remove taxa without binomials

# Align to PHMM

```{r }
dir.create("diagnostic_alignments/aligned")

# Test PHMM with tephritid mitogenomes

model <- readRDS("diagnostic_alignments/model/Bactrocera_COI.rds")

seqs <- insect::readFASTA("diagnostic_alignments/public/Tephritidae_mitochondria.fa.gz")

seqs <- seqs[1:10]

filtered <- taxreturn::map_to_model(seqs,  model, minscore = 100,
 shave=TRUE, check_indels=TRUE,  maxNs = 0,
 multithread=FALSE, quiet=FALSE, progress = FALSE)


model <- readRDS("reference/folmer_fullength_model.rds")
seqs <- insect::readFASTA("reference/database_builder/04_name_filtered.fa.gz")

#Write out results filtered results
insect::writeFASTA(filtered, file="reference/database_builder/05_filtered.fa.gz",compress=TRUE)


```

## Remove stop codons

```{r stop codons}
filtered <- insect::readFASTA("reference/database_builder/05_filtered.fa.gz")

# Filter for stop codons
codonfilt <- taxreturn::codon_filter(filtered)

#Write out results filtered results
insect::writeFASTA(codonfilt, file="reference/database_builder/06_codon_filtered.fa.gz",compress=TRUE)
```

# Filter for length

# remove chimeric sequences

TODO!

# Check for mixed clusters

```{r Mixed clusters}
codonfilt <- insect::readFASTA("reference/database_builder/06_codon_filtered.fa.gz")

# Remove duplicate accesions
seqs <- insect::subset.DNAbin(codonfilt, subset = !duplicated(str_extract(names(codonfilt), "^.*\\|" )))

# flag clusters with mixed taxonomy at different cluster thresholds and taxonomic ranks
db <- taxreturn::get_ott_taxonomy(dir="ott3.2")
set.seed(666)

mixed_clusters <- purrr::map_dfr(rev(seq(0.95, 1, 0.01)), ~taxreturn::get_mixed_clusters(
    x = seqs, db=db,
    rank = c("species","genus","family"),
    threshold = .x,
    return = "consensus",
    confidence=0.6, quiet = FALSE) 
)
write.csv(mixed_clusters,"mixedclusters.csv")

mixed_clusters <- vroom::vroom("reference/mixedclusters.csv")

gg.mixed <- mixed_clusters %>%
  group_by(threshold, rank) %>%
  summarise(n=n()) %>%
  ggplot(aes(x=as.factor(threshold), y=n, fill=rank, group=rank)) + 
  geom_bar(stat="identity", position="dodge", colour="black") +
  xlab("Clustering threshold") +
  ylab("Problem Sequences") +
  ggtitle("Mixed clusters") +
  theme_classic() +
  scale_fill_brewer(name = "Taxonomic Rank", palette="Greens") 

gg.mixed

# Purge all with mixed genus at 97, with confidence > 0.6  - >0.8 is probably better - Could i justify this with a probability of lowest common anestor?
rem <- mixed_clusters %>% 
  mutate(rem = case_when(
    rank=="species" & threshold >=0.99 & confidence > 0.8 ~ TRUE,
    rank=="genus" & threshold >=0.97 & confidence > 0.8 ~ TRUE,
    rank=="family" & threshold >=0.95 & confidence > 0.8 ~ TRUE,
    TRUE  ~ FALSE
    ))%>%
  filter(rem==TRUE) %>%
  pull(Acc) %>%
  unique()

length(rem)

purged  <- subset.DNAbin(seqs, subset = !str_replace(names(seqs), "(?:.(?!;))+$", "") %in% rem)
insect::writeFASTA(purged, file="reference/database_builder/07_purged.fa.gz", compress=TRUE)
```

# Blast against contaminants

# prune overrepresented groups

# Entropy

```{r entropy}
#Set moving average function - Adjust smoothing (n=5?)
ma <- function(x, n=3, sides=2){
  if(length(x) >= n){stats::filter(x, rep(1/n, n), sides=sides)
    }else NA_real_
  }


# Entropy & Basecomp bar plots
entropy_plots <- fs::dir_ls(path="diagnostic_alignments/aligned", glob = "*.fa") %>%
  purrr::map(function(x){
    seqs <- insect::readFASTA(x)
    ent <- taxreturn::alignment_entropy(as.list(seqs), maskgaps=1, countgaps=FALSE, 
                                        method="ML", unit="log", return_extra = TRUE) %>%
      ungroup() %>%
      mutate(ent = ent %>% 
               na_if("") %>%
               replace_na(0)) %>%
      mutate(ma = ma(ent, n = 3, sides=1)) %>%
      mutate(ma = ma %>% replace_na(0))
    
    # Plot entropy
    gg.ent <- ent %>%
      mutate(pos = as.numeric(pos)) %>%
      ggplot(aes(x = pos, y = ma))+
      geom_line() +
      theme_void()+
          scale_x_continuous(expand=c(0,0), breaks = seq(0, max(lengths(seqs)), 10))+
          scale_y_continuous(expand=c(0,0)) +
      labs( title = x %>% 
             str_remove("_aligned.*$") %>%
             str_remove("^.*/"))
    
    # Plot basecomposition
    gg.basecomp <- ent %>%
      pivot_longer(c("A", "C", "G", "T"),
                   names_to = "base",
                   values_to="value") %>%
      group_by(pos) %>%
      mutate(prob = value / sum(value)) %>%
      mutate(pos = as.numeric(pos)) %>%
      ggplot(aes(x = pos, y = prob, fill=base))+
      geom_col() +
      theme_bw()+
      scale_x_continuous(expand=c(0,0), breaks = seq(0, max(lengths(seqs)), 10))+
      scale_y_continuous(expand=c(0,0), labels=scales::percent_format()) +
      labs(x = NULL,
           y = NULL,
           fill="Base")+
      scale_fill_manual(values=c("A" = "firebrick", "T" = "green", "G" = "goldenrod", "C" = "mediumblue"))
  
    gg.ent / gg.basecomp
    
    })

gg.entropy <- wrap_plots(entropy_plots, ncol=1)


pdf(file="fig/entropy_basecomp.pdf", width = 50, height = 8)
  plot(gg.entropy)
try(dev.off(), silent=TRUE)
```


# Sliding window analysis

```{r sliding window}
# Set window parameters
win_length <- c(220, 420)
win_int <- 3

sw_results <- fs::dir_ls(path="diagnostic_alignments/aligned", glob = "*.fa") %>%
  purrr::map(function(x){
  print(x)
  seqs <- insect::readFASTA(x)
  
  # species names
  spp_names <- names(seqs) %>%
    str_remove("_*(?!.*_).*$") 
  
  # Sliding window analyses
  dat <- as.matrix(seqs)
  dimnames(dat)[[1]] <- spp_names
  
  # Make full distance matrix
  datd <- dist.dna(dat, pairwise.deletion = TRUE)

  # Create NJ tree from entire distance matrix
  dat_tr <- bionjs(datd)
  
  # Fix any negative edge lengths
  dat_tr <- fix_negative_edge_length(dat_tr, collapse_multi = TRUE)
  
 
  
  # Identification success with full tree 
  full_mono <- tibble(spp = unique(spp_names), 
               mono = monophyly(dat_tr, spp_names))
  full_nn <- tibble(seqs = names(seqs),
               spp = spp_names, 
               nn = nearNeighbour(datd, spp_names))

  # Sliding windows
  window_results <- vector("list", length=length(win_length))
  for (w in 1:length(win_length)){
    
    # Create windows
    win <- slidingWindow(dat, width=win_length[w], interval = win_int)
    pos_out <- sapply(win, function(x) attr(x, "window")[1])
    
    # Create distance matrices for each window
    win_dist <- lapply(win, function(x) dist.dna(x, pairwise.deletion = TRUE))
  
    # Get mean K2P distance per window
    dist_mean_out <- sapply(win_dist, function(x) mean(x, na.rm = TRUE))
    
    # Get number of diagnostic nucleotides      
    nd_out <- slideNucDiag(dat, spp_names, width=win_length[w], interval = win_int)
    nd_out <- colSums(nd_out)
    
    #depth <- which(node.depth(dat_tr)[node.depth(dat_tr) > 1] <= median(node.depth(dat_tr)[node.depth(dat_tr) > 1]))

    ## Make NJ trees for each window
    win_tr <- purrr::map2(win_dist, pos_out, function(y,z){
      print(z)
      # Filter out comparisons that are only NA
      y <- as.matrix(y)
      y <- y[rowSums(y, na.rm = TRUE) > 0, colSums(y, na.rm = TRUE) > 0]
      tree <- bionjs(y)
      tree <- fix_negative_edge_length(tree, collapse_multi = TRUE)
    })
      
    #Proportion of species that are monophyletic.
    win_mono <- win_tr %>%
      purrr::map(~{
        tibble(spp = unique(spp_names), 
               mono = monophyly(.x, spp_names)) %>%
          left_join(full_mono %>% dplyr::rename(full_mono = mono), by="spp") %>%
          mutate(mono_both = mono == full_mono)
      })
    
    # Get the proportion of monophyletic spp only counting ones monophyletic on full tree 
    win_mono_comp <- win_mono %>%
      purrr::map_dbl(~{
        length(which(.x$mono_both))/length(.x$mono_both)
      })
    # Get total proportion of monophyletic spp
    win_mono_all <- win_mono %>%
      purrr::map_dbl(~{
        length(which(.x$mono))/length(.x$mono)
      })
    
    #NN
    win_nn <- win_dist %>%
      purrr::map(~{
        tibble(seqs = names(seqs),
               spp = spp_names, 
               nn = nearNeighbour(.x, spp_names)) %>%
          left_join(full_nn %>% dplyr::rename(full_nn = nn), by="spp") %>%
          mutate(nn_both = nn == full_nn)
      })
    
    # Get the proportion of successful ID's only counting ones successful with full-length 
    win_nn_comp <- win_nn %>%
      purrr::map_dbl(~{
        length(which(.x$nn_both))/length(.x$nn_both)
      }) 
    # Get total proportion of successful ID's
    win_nn_all <- win_nn %>%
      purrr::map_dbl(~{
        length(which(.x$nn))/length(.x$nn)
      })
    
    # threshID
    #win_threshid <- lapply(win_dist, function(x) threshID(x, spp_names, threshold = 0.01))
    
    window_results[[w]] <- data.frame(
      win_length = win_length[w],
      pos = pos_out,
      diag = nd_out,
      k2p_dist = dist_mean_out,
      mono_comp = win_mono_comp,
      mono_all = win_mono_all,
      nn_comp = win_nn_comp,
      nn_all = win_nn_all,
      n_seqs = length(seqs),
      n_spp = length(unique(spp_names))
    )%>%
      mutate(
       #tree = list(win_tr),
        win_mono = win_mono,
        win_nn = win_nn)
  }
  
  # Calculate entropy
  ent <- taxreturn::alignment_entropy(as.list(seqs), maskgaps=1, countgaps=FALSE, 
                                        method="ML", unit="log", return_extra = TRUE) %>%
      ungroup() %>%
      mutate(ent = ent %>% 
               na_if("") %>%
               replace_na(0)) %>%
      mutate(ent_ma = ma(ent, n = win_int, sides=1)) %>%
      mutate(ent_ma = ent_ma %>% replace_na(0)) %>%
    mutate(pos = as.numeric(pos))
  
  # Create output
  out <- window_results  %>%
    bind_rows() %>%
    right_join(ent) 
  return(out)
})

sw_merged <- sw_results %>%
  bind_rows(.id = "source") %>%
  mutate(source = source %>% 
             str_remove("_aligned.*$") %>%
             str_remove("^.*/"))

#saveRDS(sw_merged, "output/rds/sw_merged.rds")

```


# Virtual PCR's

```{r virtual PCR}
sw_merged <- readRDS("output/rds/sw_merged.rds")
# Could maybe put them all on the same grid?

# All on one plot
sw_merged %>%
  filter(is.finite(k2p_dist)) %>%
  pivot_longer(c("diag", "k2p_dist", "mono_comp"),
               names_to="metric",
               values_to="value") %>%
  group_by(metric) %>%
  mutate(prop = value / sum(value) * 100) %>%
  mutate(z_norm = znorm(value)) %>%
  ungroup()%>%
  ggplot(aes(x = pos, y = z_norm, colour=metric, group=metric))+
  geom_line() + 
  theme_bw()+
  facet_grid(source~win_length, scales="free", space="free")+
      scale_x_continuous(expand=c(0,0), breaks = seq(0, max(sw_merged$pos), 20))+
      scale_y_continuous(expand=c(0,0)) +
  theme(panel.grid = element_blank())
  
# Just tree monophyly comparison
sw_merged %>%
  filter(is.finite(k2p_dist)) %>%
  pivot_longer(c("mono_comp", "nn_comp"),
               names_to="metric",
               values_to="value") %>%
  #group_by(metric) %>%
 # mutate(prop = value / sum(value) * 100) %>%
  #mutate(z_norm = znorm(value)) %>%
  ungroup()%>%
  ggplot(aes(x = pos, y = value, colour=metric))+
  geom_line() + 
  theme_bw()+
  facet_grid(source~win_length)+
      scale_x_continuous(expand=c(0,0), breaks = seq(0, max(sw_merged$pos), 20))+
      scale_y_continuous(expand=c(0,0), limits=c(0,1), labels = scales::percent_format()) +
  theme(panel.grid = element_blank())

# Just nearest neighbour comparison
sw_merged %>%
  filter(is.finite(k2p_dist)) %>%
  pivot_longer(c("nn_comp", "nn_all"),
               names_to="metric",
               values_to="value") %>%
  ungroup()%>%
  ggplot(aes(x = pos, y = value, colour=metric))+
  geom_line() + 
  theme_bw()+
  facet_grid(source~win_length)+
      scale_x_continuous(expand=c(0,0), breaks = seq(0, max(sw_merged$pos), 20))+
      scale_y_continuous(expand=c(0,0), limits=c(0,1), labels = scales::percent_format()) +
  theme(panel.grid = element_blank())

# Mono comp different lengths
# Just tree monophyly comparison
gg.mono_comparison <- sw_merged %>%
  filter(is.finite(k2p_dist), !win_length == "320") %>%
  pivot_longer(c("mono_comp"),
               names_to="metric",
               values_to="value") %>%
  ungroup()%>%
  ggplot(aes(x = pos, y = value, colour=factor(win_length)))+
  geom_line() + 
  base_theme+
  facet_grid(source~.)+
  scale_x_continuous(expand=c(0,0), breaks = seq(0, max(sw_merged$pos), 20))+
  scale_y_continuous(expand=c(0,0), limits=c(0,1), labels = scales::percent_format()) +
  scale_color_brewer(palette="Set1")+
  theme(panel.grid = element_blank(),
        legend.position = "right",
        axis.text.x = element_text(angle=0, hjust=0.5)) +
  labs(x = "Nucleotide position within alignment",
       y = "Proportion monophyletic (Compared to full tree)",
       colour = "Amplicon length")
gg.mono_comparison

pdf(file= "fig/sw_monophyly.pdf", width = 11, height = 8, paper="a4r")
  plot(gg.mono_comparison)
try(dev.off(), silent=TRUE)

# Get the best positions from each and create an amplicon from there (see primer eval code for creating the amplicon)
best_windows <- sw_merged %>%
  drop_na() %>%
  dplyr::select(-where(is.list)) %>%
  group_by(source, win_length) %>%
  #arrange(mono_comp, nn_comp) %>%
  slice_max(order_by=mono_comp, with_ties = TRUE) %>%
  slice_max(order_by=nn_comp, with_ties = TRUE) %>%
  slice_max(order_by=diag, with_ties = TRUE) %>%
  slice_max(order_by=k2p_dist, with_ties = TRUE)

dir.create("diagnostic_alignments/amplicons")

# VirutalPCR
fs::dir_ls(path="diagnostic_alignments/aligned", glob = "*.fa") %>%
  purrr::map(function(x){
    print(x)
    loci_name <- basename(as.character(x)) %>% 
    str_remove("_aligned.fa")
    
    seqs <- readDNAStringSet(x)
    
    win_dat <- best_windows %>%
      filter(source == loci_name)
    
    for (p in 1:length(win_dat$win_length)){
      amplicon <- Biostrings::subseq(seqs, start=win_dat$pos[p] + 1, end = win_dat$pos[p] + win_dat$win_length[p]) #may need to add 1 to start
    
        #maxgaps <- 9 # dont allow any more than 9 gaps
        #rem <- names(amplicon)[Biostrings::letterFrequency(amplicon, "-") > maxgaps]
        #amplicon <- amplicon[!names(amplicon) %in% rem]
        out_name <- paste0(win_dat$source[p],"_", win_dat$win_length[p],"bp")
        #message(paste0(length(rem), " Sequences with more than ", maxgaps, 
        #               " gaps removed from ",out_name))
        Biostrings::writeXStringSet(amplicon, file=paste0("diagnostic_alignments/amplicons/", out_name,".fa.gz"), compress=TRUE)
      }
  })


# create an amplicon for fwhf2-fwhr2n

```

# Loci combinatiosn

Find mix of loci that covers the most amount of species

- Combine all unique spp names covered across all alignments
- Run ID success on full locus

```{r id results}
# copy the full length aligned sequences over
fs::dir_ls(path="diagnostic_alignments/aligned/", glob = "*.fa*") %>%
  purrr::map(function(x){
    file.copy(x, paste0("diagnostic_alignments/amplicons/", str_replace(basename(as.character(x)), "aligned", "full")), overwrite = TRUE)
  })

# Get ID success with all
id_success <- fs::dir_ls(path="diagnostic_alignments/amplicons/", glob = "*.fa*") %>%
  purrr::map(function(x){
  print(x)
  seqs <- insect::readFASTA(x)
  
  loci_name <- basename(as.character(x)) %>% 
    str_remove("_aligned.fa") #%>% 
   # str_remove("_.*$")
  
  # species names
  spp_names <- names(seqs) %>%
    str_remove("_*(?!.*_).*$") 
  
  # Make full distance matrix
  dat <- as.matrix(seqs)
  dimnames(dat)[[1]] <- spp_names
  datd <- dist.dna(dat, pairwise.deletion = TRUE)

  # Create NJ tree from entire distance matrix
  dat_tr <- bionjs(datd)
  
  # Fix any negative edge lengths
  dat_tr <- fix_negative_edge_length(dat_tr, collapse_multi = TRUE)
  
  # Identification success with full tree 
  full_mono <- tibble(spp = unique(spp_names), 
               mono = monophyly(dat_tr, spp_names))
  full_nn <- tibble(seqs = names(seqs),
               spp = spp_names, 
               nn = nearNeighbour(datd, spp_names))
  
  out <- full_nn %>%
    left_join(full_mono, by="spp") %>%
    mutate(loci = loci_name) %>%
    dplyr::select(loci, spp, seqs, mono, nn) %>% 
    group_by(loci) %>% 
    nest() %>% 
    mutate(tree = list(dat_tr))
  
  # Create plot of full tree
  p1 <- ggtree(dat_tr)
  
  tree_labels <- p1$data %>% 
    left_join(full_mono %>% dplyr::rename(label = spp), by="label")
  
  p2 <- p1 %<+% tree_labels + 
    geom_tippoint(aes(colour=mono)) +
    geom_tiplab()+
    theme(legend.position = "top")+
    labs(colour = "Monophyletic") +
    scale_colour_manual(values=c("#e41a1c","#4daf4a"))
  
  # Save figure
  out.dir <-"output/trees/"
  if(!dir.exists(out.dir)){ dir.create(out.dir)}
  
  #Might be worth changing output height depending on number of seqs
  plot_height <- round(length(spp_names) / 7)
  pdf(file= paste0("output/trees/",loci_name, "_full.pdf"), width = 8, height = plot_height)
    plot(p2)
  try(dev.off(), silent=TRUE)
  
  return(out)
}) %>% 
  bind_rows()

# make supertree to arrange plot around - This shoudl be done with fulllength not subset!
tree_list <- id_success %>%
  pull(tree) 
class(tree_list) <- "multiPhylo"
supertree <- phangorn::superTree(tree_list)

#saveRDS(supertree, "output/rds/supertree.rds")
supertree <- readRDS("output/rds/supertree.rds")

# Get all taxa combinations
id_combinations <- id_success %>%
  dplyr::select(-tree) %>%
  unnest(data) %>%
  group_by(loci, spp) %>%
  dplyr::summarise(mono = paste(sort(unique(mono)), collapse = "/"), nn = paste(sort(unique(nn)), collapse = "/")) %>%
  mutate(mono = case_when(
    mono == TRUE  ~ "correct",
    mono == FALSE ~ "incorrect",
    str_detect(mono,"/") ~ "mixed"
  ),
  nn = case_when(
    nn == TRUE  ~ "correct",
    nn == FALSE ~ "incorrect",
    str_detect(nn,"/") ~ "mixed"
  )) %>%
  ungroup() %>%
  tidyr::complete(loci, spp, fill=list(mono=NA, nn=NA))

# plot tree
p1 <- ggtree(supertree, ladderize = TRUE,branch.length = "none") 
  
# Plot heatmap and arrange by tree
gg.id_comb <- id_combinations %>%
  left_join(p1$data %>% dplyr::rename(spp = label)) %>%
  filter(!str_detect(loci,"320bp")) %>%
  mutate(primer = loci %>% 
           str_remove("^.*_") %>%
           str_remove(".fa.gz")%>%
           str_remove(".fa") %>%
           factor(levels = c("full", "420bp", "220bp")), #"320bp", 
         loci = loci %>% 
           str_remove("_.*$")) %>%
  mutate(loci = factor(loci, levels =c("COI", "EIF3L", "DDOST", "RPA2", "POP4"))) %>%
  ggplot(aes(x = primer, y = fct_reorder(spp, y), fill=mono)) +
  geom_tile() +
  facet_grid(~loci, scales="free_x", space="free", drop=TRUE) +
  scale_fill_manual(values = c(correct="#66bd63", incorrect="#d73027", mixed = "#ffffbf")) + 
  base_theme +
  labs(x = "Primer set",
       y = NULL
       )
 
gg.id_multifig <- p1 + gg.id_comb + plot_layout(widths = c(1,3))

gg.id_multifig

pdf(file= "fig/id_combination.pdf", width = 8, height = 16)
  plot(gg.id_multifig)
try(dev.off(), silent=TRUE)
  
# I want to find a best combination of 2 columns that maximizes the number on non-0 values per row
# Define function
# Modified from: https://stackoverflow.com/questions/45284082/find-the-best-combination-of-columns-in-a-matrix
# It looks for the column with most non-zeros, removes those rows from the comparison, and repeats. It returns the column numbers of the n best columns.
find_top_combinations <- function(mat, n=2){
  cols <- rep(FALSE,ncol(mat)) #columns to exclude
  rows <- rep(TRUE,nrow(mat)) #rows to include
  for(i in 1:n){
    colsums <- colSums(mat[rows,])
    colsums[cols] <- -1 #to exclude those already accounted for
    maxcol <- which.max(colsums)
    cols[maxcol] <- TRUE
    rows <- rows & !as.logical(mat[,maxcol]) 
  }
  return(which(cols))
}

#Find best 2 combinations of loci - Do this for each length category
best_combinations <- id_combinations %>%
  mutate(win_length = loci %>% 
           str_remove("^.*_") %>%
           str_remove(".fa.gz")%>%
           str_remove(".fa"),
         loci = loci   %>% 
           str_remove("_.*$")%>%
           str_remove(".fa.gz")%>%
           str_remove(".fa")) %>%
  dplyr::select(-nn) %>%
  mutate(mono = case_when(
    mono == "correct" ~ 1,
    mono == "incorrect" ~ 0,
    TRUE ~ 0
  )) %>%
  distinct() %>%
  group_by(win_length) %>%
  group_modify(~{
    id_matrix <- .x %>%
      pivot_wider(names_from = loci,
              values_from = mono,
              values_fill = 0)%>%
      column_to_rownames("spp") %>%
      as.matrix()
    
    # 1 loci
    subset_matrix_1 <- id_matrix[,find_top_combinations(id_matrix, n=1)]
    n_id_1 <- length(unique(names(subset_matrix_1)[subset_matrix_1 == 1]))
    # 2 loci
    subset_matrix_2 <- id_matrix[,find_top_combinations(id_matrix, n=2)]
    n_id_2 <- length(unique(rownames(subset_matrix_2)[rowSums(subset_matrix_2)> 0]))
    # 3 loci
    subset_matrix_3 <- id_matrix[,find_top_combinations(id_matrix, n=3)]
    n_id_3 <- length(unique(rownames(subset_matrix_3)[rowSums(subset_matrix_3)> 0]))
    # 4 loci
    subset_matrix_4 <- id_matrix[,find_top_combinations(id_matrix, n=4)]
    n_id_4 <- length(unique(rownames(subset_matrix_4)[rowSums(subset_matrix_4)> 0]))
    
    tribble(
      ~n_loci, ~comb, ~n_id, ~n_total, ~failed,
      "1", colnames(id_matrix)[find_top_combinations(id_matrix, n=1)], n_id_1, length(unique(names(subset_matrix_1))), names(subset_matrix_1)[subset_matrix_1 == 0],
      "2", paste(colnames(subset_matrix_2), collapse = "/"), n_id_2, length(unique(rownames(subset_matrix_2))), rownames(subset_matrix_2)[rowSums(subset_matrix_2) == 0],
      "3", paste(colnames(subset_matrix_3), collapse = "/"), n_id_3, length(unique(rownames(subset_matrix_3))), rownames(subset_matrix_3)[rowSums(subset_matrix_3) == 0],
      "4", paste(colnames(subset_matrix_4), collapse = "/"), n_id_4, length(unique(rownames(subset_matrix_4))), rownames(subset_matrix_4)[rowSums(subset_matrix_4) == 0]
    )
  })

# Look at gain in accuracy as you add more loci - Do this for each length category
gg.id_bars <- best_combinations %>%
  group_by(win_length, n_loci) %>%
  mutate(prop_id =  n_id / n_total) %>%
  ungroup() %>%
  filter(!win_length == "320bp") %>%
  mutate(win_length = win_length %>%
           factor(levels = c("full", "420bp", "220bp"))) %>% #"320bp",
  mutate(n_loci = as.numeric(n_loci)) %>%
  ggplot(aes(x = fct_reorder(comb, n_loci), y = prop_id, fill = as.factor(n_loci)))+
  geom_col() + 
  geom_text(aes(label=n_id), vjust = -0.5)+
  facet_grid(~win_length, space="free", scales="free_x", drop=TRUE) +
  base_theme + 
  scale_y_continuous(labels= scales::percent_format())+
  scale_fill_brewer(palette="Paired") +
  labs(x = "Marker combination",
       y = "Percentage identified")

gg.id_bars

pdf(file= "fig/id_combination_bars.pdf", width = 11, height = 8, paper="a4r")
  plot(gg.id_bars)
try(dev.off(), silent=TRUE)
  

# look at what species are gained when you add another by each

failed_id_combinations <- best_combinations %>% 
  #unnest_longer(failed) %>%
  mutate(lagged = lag(failed)) %>%
  mutate(gain =  map2(lagged, failed, function(x,y){
    setdiff(x, y)
    }) )

gg.id_heat <- failed_id_combinations %>%
  unnest_longer(gain) %>%
  mutate(win_length = win_length %>%
           factor(levels = c("full", "420bp", "320bp", "220bp"))) %>%
  ggplot(aes(x = fct_reorder(comb, n_loci), y= gain))+
  #geom_tile()+
  geom_text(aes(label=gain))+
  facet_grid(~win_length, space="free", scales="free", drop=TRUE) +
  base_theme + 
  scale_fill_brewer(palette="Paired") +
  labs(x = "Marker combination",
       y = "Percentage identified")
  

gg.id_bars / gg.id_heat

# Look at difference betwene a COI + EIF3L at 420 vs 220 bp
comp1 <- failed_id_combinations %>%
  filter(comb == "COI/EIF3L", win_length == "220bp") %>%
  pull(failed) %>%
  unlist()

comp2 <- failed_id_combinations %>%
  filter(comb == "COI/EIF3L", win_length == "420bp") %>%
  pull(failed) %>%
  unlist()

setdiff(comp1, comp2)
```



 Primer design 

Rules:
2 GC bases
Think about the length of your primers (20-25 bp is usually ideal) and the region you’re copying
Aim for a GC content of 40-60 %
Pay particular attention to the 3′ end, especially with Gs and Cs
Avoid repeats of one or two bases more than four times
Ideally keep the melting temperature around the 60 °C mark
Try to keep the melting temperatures within 5 °C between the forward and reverse
Check for self-dimerisation or dimerisation between the forward and reverse
Consider degenerate bases (but not too many)

 
 Identification success for each primer set

- Chop the alignment to the region amplified
- Calculate the differentiation at a giver percentage ID
- Make a tree + heatmap for each indivuald primer, colour by whether its correctly identified or not

 Identification success for multiple loci

- Calculate all possible cobinations of loci
- Create a tree + heatmap for whether each combination can correctly identify each taxa


# Sequence logos

```{r Create sequence logos}
library(ggseqlogo)

seq_logos <- fs::dir_ls(path="diagnostic_alignments/aligned", glob = "*.fa") %>%
  purrr::map(function(x){
    seqs <- dna2char(insect::readFASTA(x))
    ggplot() + 
      geom_logo(seqs) + 
      theme_logo() +
      labs(title = x %>% 
             str_remove("_aligned.*$") %>%
             str_remove("^.*/")) +
      scale_x_continuous(expand=c(0,0), breaks = seq(0, max(sapply(seqs, nchar)), 10))+
      scale_y_continuous(expand=c(0,0))
  })

gg.seq_logos <- wrap_plots(seq_logos, ncol=1)


pdf(file="fig/seq_logos.pdf", width = 50, height = 8)
  plot(gg.seq_logos)
try(dev.off(), silent=TRUE)

```



# Predicted mismatch

```{r Primerminer, message=FALSE}
library(PrimerMiner)
## Target sequences to test against
seqs <- insect::readFASTA("reference/merged_final.fa.gz")
names(seqs) <- names(seqs) %>% str_replace_all(" ", "_")
writeFASTA(seqs, "primer_evaluation/merged_final_target.fa")

target <- "primer_evaluation/merged_final_target.fa"

# Load primers
primers <- read_csv("primer_evaluation/primer_candidates.csv") %>%
  mutate(seq = str_replace_all(seq, "I","N")) %>% 
  select(-score, -issues)

dir.create("primer_evaluation/PrimerMiner")

for (i in 1:nrow(primers)) {
  if(primers$strand[i]=="F"){
  evaluate_primer(target,
   as.character(primers$seq[i]), primers$start[i], primers$end[i],
   forward = TRUE, gap_NA = TRUE, N_NA=TRUE,
   mm_position = "Position_v1", mm_type = "Type_v1", adjacent = 2,
   save = paste0("primer_evaluation/PrimerMiner/", primers$name[i],".csv")
  )
  } else if(primers$strand[i]=="R"){
  evaluate_primer(target,
   as.character(primers$seq[i]), primers$start[i], primers$end[i],
   forward = FALSE, gap_NA = TRUE, N_NA=TRUE,
   mm_position = "Position_v1", mm_type = "Type_v1", adjacent = 2,
   save = paste0("primer_evaluation/PrimerMiner/", primers$name[i],".csv")
  )
 }
}

# gZip files
fs::dir_ls(path="primer_evaluation/PrimerMiner", glob = "*.csv") %>%
  purrr::map(R.utils::gzip)

```


## SW gifs

```{r sw gif}
# Make directory for gifs
dir.create("gifs")

# Set window parameters
win_length <- 220
win_int <- 20

fs::dir_ls(path="diagnostic_alignments/aligned", glob = "*.fa") %>%
  purrr::map(function(x){
  print(x)
  seqs <- insect::readFASTA(x)
  
  loci_name <- x %>% str_remove(".*/") %>% str_remove("_.*$")

  spp_names <- names(seqs) %>%
    str_remove("_*(?!.*_).*$") 
  
  # Sliding window analyses
  dat <- as.matrix(seqs)
  dimnames(dat)[[1]] <- spp_names
  
  # Make full distance matrix
  datd <- dist.dna(dat, pairwise.deletion = TRUE)

  # Create windows
  win <- slidingWindow(dat, width=win_length, interval = win_int)
  pos_out <- sapply(win, function(x) attr(x, "window")[1])
  
  # Create distance matrices for each window
  win_dist <- lapply(win, function(x) dist.dna(x, pairwise.deletion = TRUE))

  ## Make NJ trees for each window
  win_tr <- purrr::map2(win_dist,pos_out, function(y,z){
    print(z)
    # Filter out comparisons that are only NA
    y <- as.matrix(y)
    y <- y[rowSums(y, na.rm = TRUE) > 0, colSums(y, na.rm = TRUE) > 0]
    tree <- njs(y)
    
    if(!all(is.finite(tree$edge.length))) {return(NULL)}

     p1 <- ggtree(tree)    
    
    # Highlight monophyletic taxa
    mono <- p1$data %>% 
      left_join(data.frame( label = unique(spp_names),
                        mono = monophyly(tree, spp_names)), by="label")
    p2 <- p1 %<+% mono + 
      geom_tippoint(aes(colour=mono)) +
      theme(legend.position = "top")+
      labs(colour = "Monophyletic",
           title = loci_name) +
      scale_colour_manual(values=c("#e41a1c","#4daf4a"))
    
    # Create SW visualisation
    sw_plot <- enframe(seq(1,ncol(dat), 1), name = NULL, value="pos") %>%
      mutate(in_win = between(pos, z, z+ win_length)) %>%
      ggplot(aes(x = pos, y = 1, fill=in_win)) +
      geom_tile() +
      scale_x_continuous(expand=c(0,0), breaks = seq(0, ncol(dat), 50))+
      scale_y_continuous(expand=c(0,0)) +
      scale_fill_manual(values = c("grey80","firebrick"))+
      theme(axis.text.y  = element_blank(),
            axis.ticks.y = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "none") +
      labs(x = "Nucleotide position")
      
    out <- p2 / sw_plot + plot_layout(heights = c(20,1))
    
    return(out)
  })
  
 # Remove failed plots
 win_tr <- win_tr[!sapply(win_tr, is.null)]

 out_name <- normalizePath(paste0("gifs/", loci_name ,"_windows.gif"))
 
 # Plot gif
 animation::saveGIF(
   expr = {
    purrr::walk(win_tr, ~{
      plot(.x)
    })
   },
   movie.name = out_name,
   ani.width=620 ,
   ani.height=877,
   interval=2,
   autobrowse=FALSE
 )
 try(dev.off(), silent=TRUE)
  
})

```
